{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"gwaslab Note: Some part of the docs are outdated. I am currently updating the documents. A simple python package for handling GWAS sumstats. Each process is modularized and can be customized to your needs. Most manipulations are designed as methods of python object, gwaslab.Sumstats . Please check GWASLab document at https://cloufield.github.io/gwaslab/ Install pip install gwaslab==3.3.3 import gwaslab as gl # load plink2 output mysumstats = gl.Sumstats(\"t2d_bbj.txt.gz\", fmt=\"plink2\") # or you can specify the columns: mysumstats = gl.Sumstats(\"t2d_bbj.txt.gz\", snpid=\"SNP\", chrom=\"CHR\", pos=\"POS\", ea=\"ALT\", nea=\"REF\", neaf=\"Frq\", beta=\"BETA\", se=\"SE\", p=\"P\", direction=\"Dir\", n=\"N\", build=\"19\") # manhattan and qq plot mysumstats.plot_mqq() ... Functions Loading and Formatting Loading sumstats by simple specifying the software name Optional Filtering of Hapmap3 / High-LD region / HLA when output sumtats Converting GWAS sumstats to specific formats LDSC / MAGMA / METAL / MR-MEGA / FUMA / VCF / BED... check available formats Standardization & Normalization Variant ID standardization CHR and POS notation standardization Variant POS and allele normalization Genome build : Infer and Liftover Quality control, Value conversion & Filtering General statistics sanity check Extreme value removal Equivalent statistics conversion BETA/SE , OR/OR_95L/OR_95U P, Z, CHISQ, MLOG10 Customized value filtering. Harmonization rsID assignment based on CHR, POS, and REF/ALT CHR POS assignment based on rsID using a reference text file Palindromic SNPs and indels strand inference using a reference VCF Check allele frequency discrepancy using a reference VCF Reference allele alignment using a reference genome sequence FASTA file Visualization Mqq plot : Manhattan plot , QQ plot or MQQ plot (with a bunch of customizable features including auto-annotate nearest gene names) Miami plot : Manhattan plot Brisbane plot: GWAS hits density plot Regional plot : GWAS regional plot Heatmap : ldsc-rg genetic correlation matrix Scatter Plot : variant effect size comparison with sumstats Scatter Plot : allele frequency comparison Forest Plot : forest plots for meta-analysis of SNPs Visualization Examples Other Utilities Read ldsc h2 or rg outputs directly as DataFrames (auto-parsing). Extract lead variants given a sliding window size. Extract novel loci given a list of known lead variants. Logging : keep a complete record of manipulations from raw data to munged data. Sumstats summary function: know your data better. Requirements: Python >= 3.6 pySAM pyensembl scikit-allel Biopython >= 1.79 liftover >= 1.1.13 pandas >= 1.2.4 numpy >= 1.21.2 matplotlib >=3.5 seaborn >=0.11.1 scipy >=1.6.2 statsmodels > =0.13 adjustText Contacts Github: https://github.com/Cloufield/gwaslab Blog (in Chinese): https://gwaslab.com/ Email: gwaslab@gmail.com","title":"Home"},{"location":"#gwaslab","text":"Note: Some part of the docs are outdated. I am currently updating the documents. A simple python package for handling GWAS sumstats. Each process is modularized and can be customized to your needs. Most manipulations are designed as methods of python object, gwaslab.Sumstats . Please check GWASLab document at https://cloufield.github.io/gwaslab/","title":"gwaslab"},{"location":"#install","text":"pip install gwaslab==3.3.3 import gwaslab as gl # load plink2 output mysumstats = gl.Sumstats(\"t2d_bbj.txt.gz\", fmt=\"plink2\") # or you can specify the columns: mysumstats = gl.Sumstats(\"t2d_bbj.txt.gz\", snpid=\"SNP\", chrom=\"CHR\", pos=\"POS\", ea=\"ALT\", nea=\"REF\", neaf=\"Frq\", beta=\"BETA\", se=\"SE\", p=\"P\", direction=\"Dir\", n=\"N\", build=\"19\") # manhattan and qq plot mysumstats.plot_mqq() ...","title":"Install"},{"location":"#functions","text":"","title":"Functions"},{"location":"#loading-and-formatting","text":"Loading sumstats by simple specifying the software name Optional Filtering of Hapmap3 / High-LD region / HLA when output sumtats Converting GWAS sumstats to specific formats LDSC / MAGMA / METAL / MR-MEGA / FUMA / VCF / BED... check available formats","title":"Loading and Formatting"},{"location":"#standardization-normalization","text":"Variant ID standardization CHR and POS notation standardization Variant POS and allele normalization Genome build : Infer and Liftover","title":"Standardization &amp; Normalization"},{"location":"#quality-control-value-conversion-filtering","text":"General statistics sanity check Extreme value removal Equivalent statistics conversion BETA/SE , OR/OR_95L/OR_95U P, Z, CHISQ, MLOG10 Customized value filtering.","title":"Quality control, Value conversion &amp; Filtering"},{"location":"#harmonization","text":"rsID assignment based on CHR, POS, and REF/ALT CHR POS assignment based on rsID using a reference text file Palindromic SNPs and indels strand inference using a reference VCF Check allele frequency discrepancy using a reference VCF Reference allele alignment using a reference genome sequence FASTA file","title":"Harmonization"},{"location":"#visualization","text":"Mqq plot : Manhattan plot , QQ plot or MQQ plot (with a bunch of customizable features including auto-annotate nearest gene names) Miami plot : Manhattan plot Brisbane plot: GWAS hits density plot Regional plot : GWAS regional plot Heatmap : ldsc-rg genetic correlation matrix Scatter Plot : variant effect size comparison with sumstats Scatter Plot : allele frequency comparison Forest Plot : forest plots for meta-analysis of SNPs","title":"Visualization"},{"location":"#visualization-examples","text":"","title":"Visualization Examples"},{"location":"#other-utilities","text":"Read ldsc h2 or rg outputs directly as DataFrames (auto-parsing). Extract lead variants given a sliding window size. Extract novel loci given a list of known lead variants. Logging : keep a complete record of manipulations from raw data to munged data. Sumstats summary function: know your data better.","title":"Other Utilities"},{"location":"#requirements","text":"Python >= 3.6 pySAM pyensembl scikit-allel Biopython >= 1.79 liftover >= 1.1.13 pandas >= 1.2.4 numpy >= 1.21.2 matplotlib >=3.5 seaborn >=0.11.1 scipy >=1.6.2 statsmodels > =0.13 adjustText","title":"Requirements:"},{"location":"#contacts","text":"Github: https://github.com/Cloufield/gwaslab Blog (in Chinese): https://gwaslab.com/ Email: gwaslab@gmail.com","title":"Contacts"},{"location":"AlleleFrequency/","text":"Scatter & Distribution plot : allele frequency comparison sumstats.plot_daf()","title":"Scatter: allele frequency comparison"},{"location":"BrisbanePlot/","text":"Brisbane plot mysumstats = gl.Sumstats(\"height_lead.tsv\", snpid=\"SNP\", chrom=\"Chr\", pos=\"BP_HG19\", p=\"P-value\") mysumstats.plot_mqq(mode=\"b\",anno=\"GENENAME\", build=\"19\",anno_fixed_arm_length=2, anno_args={\"rotation\":90}, marker_size=(30,30),sig_line_color=\"red\") mode=\"b\" : plot Brisbane plot ! bwindowsizekb = 100 : windowsize in kb. Citation:Yengo, L., Vedantam, S., Marouli, E., Sidorenko, J., Bartell, E., Sakaue, S., ... & Lee, J. Y. (2022). A saturated map of common genetic variants associated with human height. Nature, 1-16.","title":"Brisbane Plot"},{"location":"BrisbanePlot/#brisbane-plot","text":"mysumstats = gl.Sumstats(\"height_lead.tsv\", snpid=\"SNP\", chrom=\"Chr\", pos=\"BP_HG19\", p=\"P-value\") mysumstats.plot_mqq(mode=\"b\",anno=\"GENENAME\", build=\"19\",anno_fixed_arm_length=2, anno_args={\"rotation\":90}, marker_size=(30,30),sig_line_color=\"red\") mode=\"b\" : plot Brisbane plot ! bwindowsizekb = 100 : windowsize in kb. Citation:Yengo, L., Vedantam, S., Marouli, E., Sidorenko, J., Bartell, E., Sakaue, S., ... & Lee, J. Y. (2022). A saturated map of common genetic variants associated with human height. Nature, 1-16.","title":"Brisbane plot"},{"location":"CommonData/","text":"Commonly used data in gwaslab Chromosme notation conversion dictionary get_chr_list() : get a full list of chromosomes chr/ number <-> NC dictionary get_chr_to_NC(build) : get_number_to_NC(build) get_NC_to_chr(build) get_NC_to_number(build) chr <-> number get_chr_to_number() get_number_to_chr() High-ld region bed get_high_ld(build) Sumstats Format list get_format_dict(fmt) get_formats_list() Gene gtf get_gtf(chrom, build=\"19\",source=\"ensembl\") gwaslab information gwaslab_info()","title":"Common data"},{"location":"CommonData/#commonly-used-data-in-gwaslab","text":"","title":"Commonly used data in gwaslab"},{"location":"CommonData/#chromosme-notation-conversion-dictionary","text":"get_chr_list() : get a full list of chromosomes chr/ number <-> NC dictionary get_chr_to_NC(build) : get_number_to_NC(build) get_NC_to_chr(build) get_NC_to_number(build) chr <-> number get_chr_to_number() get_number_to_chr()","title":"Chromosme notation conversion dictionary"},{"location":"CommonData/#high-ld-region-bed","text":"get_high_ld(build)","title":"High-ld region bed"},{"location":"CommonData/#sumstats-format-list","text":"get_format_dict(fmt) get_formats_list()","title":"Sumstats Format list"},{"location":"CommonData/#gene-gtf","text":"get_gtf(chrom, build=\"19\",source=\"ensembl\")","title":"Gene gtf"},{"location":"CommonData/#gwaslab-information","text":"gwaslab_info()","title":"gwaslab information"},{"location":"Conversion/","text":"Statistics conversion gwaslab can convert equvalent statistics, including: - P => MLOG10P - MLOG10P => P - Z => P - CHISQ => P - BETA/SE => OR/OR_95L/OR_95U - OR/OR_95L/OR_95U => BETA/SE - BETA/SE => Z - P => CHISQ - Z => CHISQ fill_data() mysumstats.fill_data( to_fill=[], df=None, overwrite=False, only_sig=False ) Options to_fill : the columns to fill. [\"OR\",\"OR_95L\",\"OR_95U\",\"BETA\",\"SE\",\"P\",\"MLOG10P\",\"Z\",\"CHISQ\"] df : columns name for degree of freedom overwrite : if overwrite when the specified column existed only_sig : fill the data only for significant variants Priority For P : using MLOG10P, Z, CHISQ For MLOG10P : using P, MLOG10P, Z, CHISQ For BETA/SE : using OR/OR_95L/OR_95U For OR/OR_95L/OR_95U : using BETA/SE For Z : using BETA/SE For CHISQ : using Z, P Example More examples: Utility_data_conversion # raw data #SNPID CHR POS EA NEA EAF BETA SE P STATUS #1:725932_G_A 1 725932 G A 0.9960 -0.0737 0.1394 0.5970 9999999 #1:725933_A_G 1 725933 G A 0.0040 0.0737 0.1394 0.5973 9999999 #1:737801_T_C 1 737801 C T 0.0051 0.0490 0.1231 0.6908 9999999 # let's fill \"MLOG10P\",\"Z\",\"OR\",\"OR_95L\",\"OR_95U\" # gwaslab will automatically search for equivalent statistics mysumstats.fill_data(to_fill=[\"MLOG10P\",\"Z\",\"OR\",\"OR_95L\",\"OR_95U\"]) Wed Oct 19 10:13:30 2022 Start filling data using existing columns... Wed Oct 19 10:13:30 2022 -Raw input columns: ['SNPID', 'CHR', 'POS', 'EA', 'NEA', 'EAF', 'BETA', 'SE', 'P', 'STATUS'] Wed Oct 19 10:13:30 2022 -Overwrite mode: False Wed Oct 19 10:13:30 2022 - Skipping columns: [] Wed Oct 19 10:13:30 2022 Filling columns: ['MLOG10P', 'OR', 'OR_95L', 'OR_95U'] Wed Oct 19 10:13:30 2022 - Filling OR using BETA column... Wed Oct 19 10:13:31 2022 - Filling OR_95L/OR_95U using BETA/SE columns... Wed Oct 19 10:13:32 2022 - Filling MLOG10P using P column... Wed Oct 19 10:13:38 2022 Finished filling data using existing columns.","title":"Data conversion"},{"location":"Conversion/#statistics-conversion","text":"gwaslab can convert equvalent statistics, including: - P => MLOG10P - MLOG10P => P - Z => P - CHISQ => P - BETA/SE => OR/OR_95L/OR_95U - OR/OR_95L/OR_95U => BETA/SE - BETA/SE => Z - P => CHISQ - Z => CHISQ","title":"Statistics conversion"},{"location":"Conversion/#fill_data","text":"mysumstats.fill_data( to_fill=[], df=None, overwrite=False, only_sig=False )","title":"fill_data()"},{"location":"Conversion/#options","text":"to_fill : the columns to fill. [\"OR\",\"OR_95L\",\"OR_95U\",\"BETA\",\"SE\",\"P\",\"MLOG10P\",\"Z\",\"CHISQ\"] df : columns name for degree of freedom overwrite : if overwrite when the specified column existed only_sig : fill the data only for significant variants","title":"Options"},{"location":"Conversion/#priority","text":"For P : using MLOG10P, Z, CHISQ For MLOG10P : using P, MLOG10P, Z, CHISQ For BETA/SE : using OR/OR_95L/OR_95U For OR/OR_95L/OR_95U : using BETA/SE For Z : using BETA/SE For CHISQ : using Z, P","title":"Priority"},{"location":"Conversion/#example","text":"More examples: Utility_data_conversion # raw data #SNPID CHR POS EA NEA EAF BETA SE P STATUS #1:725932_G_A 1 725932 G A 0.9960 -0.0737 0.1394 0.5970 9999999 #1:725933_A_G 1 725933 G A 0.0040 0.0737 0.1394 0.5973 9999999 #1:737801_T_C 1 737801 C T 0.0051 0.0490 0.1231 0.6908 9999999 # let's fill \"MLOG10P\",\"Z\",\"OR\",\"OR_95L\",\"OR_95U\" # gwaslab will automatically search for equivalent statistics mysumstats.fill_data(to_fill=[\"MLOG10P\",\"Z\",\"OR\",\"OR_95L\",\"OR_95U\"]) Wed Oct 19 10:13:30 2022 Start filling data using existing columns... Wed Oct 19 10:13:30 2022 -Raw input columns: ['SNPID', 'CHR', 'POS', 'EA', 'NEA', 'EAF', 'BETA', 'SE', 'P', 'STATUS'] Wed Oct 19 10:13:30 2022 -Overwrite mode: False Wed Oct 19 10:13:30 2022 - Skipping columns: [] Wed Oct 19 10:13:30 2022 Filling columns: ['MLOG10P', 'OR', 'OR_95L', 'OR_95U'] Wed Oct 19 10:13:30 2022 - Filling OR using BETA column... Wed Oct 19 10:13:31 2022 - Filling OR_95L/OR_95U using BETA/SE columns... Wed Oct 19 10:13:32 2022 - Filling MLOG10P using P column... Wed Oct 19 10:13:38 2022 Finished filling data using existing columns.","title":"Example"},{"location":"EffectSize/","text":"Scatter plot : effect size comparison gl.compare_effect() gl.compare_effect( path1, cols_name_list_1, effect_cols_list_1, path2, cols_name_list_2, effect_cols_list_2, eaf=[], maf_level=None, label=[\"Sumstats_1\",\"Sumstats_2\",\"Both\",\"None\"], snplist=None, mode=\"beta\", anno=False, null_beta=0, is_q=True, q_level=0.05, sig_level=5e-8, legend_title=r'$ P < 5 x 10^{-8}$ in:', legend_pos='upper left', reg_box=dict(boxstyle='round', facecolor='white', alpha=1,edgecolor=\"grey\"), is_reg=True, is_45_helper_line=True, scatterargs={\"s\":20}, plt_args={\"figsize\":(8,8),\"dpi\":300}, xylabel_prefix=\"Per-allele effect size in \", helper_line_args={\"color\":'black', \"linestyle\":'-',\"lw\":1}, fontargs={'family':'sans','fontname':'Arial','fontsize':12}, errargs={\"ecolor\":\"#cccccc\",\"elinewidth\":1}, sep=[\"\\t\",\"\\t\"], log = Log(), verbose=False): Options path and column path1 and path2 : the paths to the sumstats. cols_name_list_1 and cols_name_list_2 : list of column names for variants basic information effect_cols_list_1 and effect_cols_list_1 : list of column names for effect size-related columns mode : use beta or OR examples: [snpid,p,ea,nea] ,[effect,se] [snpid,p,ea,nea,chr,pos],[effect,se] [snpid,p,ea,nea,chr,pos],[OR,OR_l,OR_h] snplist snplist : optional, specify the variants you want to compare. If None, gwaslab will automatically extract lead variants from both sumstats. filter by maf: eaf : optional, a list column names for effect allele frequency, in the order of [sumstats1_eaf, sumstats2_eaf]. It is needed when you need to filter by maf using maf_level . maf_level : the maf filter for variants. Vairants with maf < maf_level will be removed from comparison. label and annotation label : a list of labels for the legend , in the order of [\"Sumstats_1\",\"Sumstats_2\",\"Both\",\"None\"]. anno : if annotate the variants sig_level : the significance level for auto-extracting lead variants. legend_title : r'$ P < 5 x 10^{-8}$ in:', legend_pos : legend position, default: 'upper left' xylabel_prefix : \"Per-allele effect size in \" is_reg : draw regression line or not is_45_helper_line : draw 45 degree line or not heterogeneity test is_q : if apply the heterogeneity tests by Cochran's Q test. q_level : the significance threshold for Cochran's Q test. Example: # Smoking behaviors : Smoking initiation (autosome, male) !wget -O smoking_male.txt.gz http://jenger.riken.jp/16/ # Smoking behaviors : Smoking initiation (autosome, female) !wget -O smoking_female.txt.gz http://jenger.riken.jp/18/ # SNP CHR POS A1 A2 A1Frq Rsq BETA SE P # gwaslab will automatically extract significant variants from both sumstats. a = gl.compare_effect(\"smoking_female.txt.gz\", [\"SNP\",\"P\",\"A1\",\"A2\",\"CHR\",\"POS\"],[\"BETA\",\"SE\"], \"smoking_male.txt.gz\", [\"SNP\",\"P\",\"A1\",\"A2\",\"CHR\",\"POS\"],[\"BETA\",\"SE\"], label=[\"Female\",\"Male\",\"Both\",\"None\"], xylabel_prefix=\"Per-allele effect size for \", sig_level=5e-6, legend_title=r'$ P < 5 x 10^{-6}$ in:', verbose=True)","title":"Scatter: effect size comparison"},{"location":"EffectSize/#scatter-plot-effect-size-comparison","text":"","title":"Scatter plot : effect size comparison"},{"location":"EffectSize/#glcompare_effect","text":"gl.compare_effect( path1, cols_name_list_1, effect_cols_list_1, path2, cols_name_list_2, effect_cols_list_2, eaf=[], maf_level=None, label=[\"Sumstats_1\",\"Sumstats_2\",\"Both\",\"None\"], snplist=None, mode=\"beta\", anno=False, null_beta=0, is_q=True, q_level=0.05, sig_level=5e-8, legend_title=r'$ P < 5 x 10^{-8}$ in:', legend_pos='upper left', reg_box=dict(boxstyle='round', facecolor='white', alpha=1,edgecolor=\"grey\"), is_reg=True, is_45_helper_line=True, scatterargs={\"s\":20}, plt_args={\"figsize\":(8,8),\"dpi\":300}, xylabel_prefix=\"Per-allele effect size in \", helper_line_args={\"color\":'black', \"linestyle\":'-',\"lw\":1}, fontargs={'family':'sans','fontname':'Arial','fontsize':12}, errargs={\"ecolor\":\"#cccccc\",\"elinewidth\":1}, sep=[\"\\t\",\"\\t\"], log = Log(), verbose=False):","title":"gl.compare_effect()"},{"location":"EffectSize/#options","text":"","title":"Options"},{"location":"EffectSize/#path-and-column","text":"path1 and path2 : the paths to the sumstats. cols_name_list_1 and cols_name_list_2 : list of column names for variants basic information effect_cols_list_1 and effect_cols_list_1 : list of column names for effect size-related columns mode : use beta or OR examples: [snpid,p,ea,nea] ,[effect,se] [snpid,p,ea,nea,chr,pos],[effect,se] [snpid,p,ea,nea,chr,pos],[OR,OR_l,OR_h]","title":"path and column"},{"location":"EffectSize/#snplist","text":"snplist : optional, specify the variants you want to compare. If None, gwaslab will automatically extract lead variants from both sumstats.","title":"snplist"},{"location":"EffectSize/#filter-by-maf","text":"eaf : optional, a list column names for effect allele frequency, in the order of [sumstats1_eaf, sumstats2_eaf]. It is needed when you need to filter by maf using maf_level . maf_level : the maf filter for variants. Vairants with maf < maf_level will be removed from comparison.","title":"filter by maf:"},{"location":"EffectSize/#label-and-annotation","text":"label : a list of labels for the legend , in the order of [\"Sumstats_1\",\"Sumstats_2\",\"Both\",\"None\"]. anno : if annotate the variants sig_level : the significance level for auto-extracting lead variants. legend_title : r'$ P < 5 x 10^{-8}$ in:', legend_pos : legend position, default: 'upper left' xylabel_prefix : \"Per-allele effect size in \" is_reg : draw regression line or not is_45_helper_line : draw 45 degree line or not","title":"label and annotation"},{"location":"EffectSize/#heterogeneity-test","text":"is_q : if apply the heterogeneity tests by Cochran's Q test. q_level : the significance threshold for Cochran's Q test.","title":"heterogeneity test"},{"location":"EffectSize/#example","text":"# Smoking behaviors : Smoking initiation (autosome, male) !wget -O smoking_male.txt.gz http://jenger.riken.jp/16/ # Smoking behaviors : Smoking initiation (autosome, female) !wget -O smoking_female.txt.gz http://jenger.riken.jp/18/ # SNP CHR POS A1 A2 A1Frq Rsq BETA SE P # gwaslab will automatically extract significant variants from both sumstats. a = gl.compare_effect(\"smoking_female.txt.gz\", [\"SNP\",\"P\",\"A1\",\"A2\",\"CHR\",\"POS\"],[\"BETA\",\"SE\"], \"smoking_male.txt.gz\", [\"SNP\",\"P\",\"A1\",\"A2\",\"CHR\",\"POS\"],[\"BETA\",\"SE\"], label=[\"Female\",\"Male\",\"Both\",\"None\"], xylabel_prefix=\"Per-allele effect size for \", sig_level=5e-6, legend_title=r'$ P < 5 x 10^{-6}$ in:', verbose=True)","title":"Example:"},{"location":"ExtractLead/","text":"Extract lead variants mysumstats.get_lead( windowsizekb=500, sig_level=5e-8, xymt=[\"X\",\"Y\",\"MT\"], anno=False, build=\"19\", source=\"ensembl\", verbose=True) GWASLab will extract the lead variants from identified significant loci based on a sliding window (default window size: 500kb). (Details are described in ) Options: windowsizekb :specify the sliding window size in kb (default: 500) sig_level :specify the P value threshold (default: 5e-8). xymt : list of notation for chrX, chrY and chrMT. anno : boolean if annotate the lead variants with nearest gene names. build : string genome build version \"19\" or \"38\". Return a dataframe of the lead variants Example Sample sumstats: IS from pheweb.jp https://pheweb.jp/pheno/IS mysumstats = gl.Sumstats(\"./hum0197.v3.BBJ.IS.v1/GWASsummary_IS_Japanese_SakaueKanai2020.auto.txt.gz\", fmt=\"saige\") mysumstats.get_lead()","title":"Extract Lead Variants"},{"location":"ExtractLead/#extract-lead-variants","text":"mysumstats.get_lead( windowsizekb=500, sig_level=5e-8, xymt=[\"X\",\"Y\",\"MT\"], anno=False, build=\"19\", source=\"ensembl\", verbose=True) GWASLab will extract the lead variants from identified significant loci based on a sliding window (default window size: 500kb). (Details are described in ) Options: windowsizekb :specify the sliding window size in kb (default: 500) sig_level :specify the P value threshold (default: 5e-8). xymt : list of notation for chrX, chrY and chrMT. anno : boolean if annotate the lead variants with nearest gene names. build : string genome build version \"19\" or \"38\". Return a dataframe of the lead variants","title":"Extract lead variants"},{"location":"ExtractLead/#example","text":"Sample sumstats: IS from pheweb.jp https://pheweb.jp/pheno/IS mysumstats = gl.Sumstats(\"./hum0197.v3.BBJ.IS.v1/GWASsummary_IS_Japanese_SakaueKanai2020.auto.txt.gz\", fmt=\"saige\") mysumstats.get_lead()","title":"Example"},{"location":"ExtractNovel/","text":"Coming soon","title":"Extract Novel Variants"},{"location":"ExtractNovel/#coming-soon","text":"","title":"Coming soon"},{"location":"ForestPlot/","text":"Coming soon","title":"Forest Plot"},{"location":"ForestPlot/#coming-soon","text":"","title":"Coming soon"},{"location":"Format/","text":"Output sumstats in certain formats to_format( path=\"./sumstats\", fmt=\"ldsc\", extract=None, exclude=None, id_use=\"rsID\", hapmap3=False, exclude_hla=False, build=\"19\", verbose=True, output_log=True, to_csvargs={}, float_formats={}, xymt_number=False, xymt=[\"X\",\"Y\",\"MT\"], chr_prefix=None, bgzip=False, tabix=False ) path : string , the path for the output, only prefix is needed. fmt =\"ldsc\": output format for sumstats. Currently support plink , plink2 , ldsc , saige , fastgwa , regenie . For details , please check https://github.com/Cloufield/formatbook . extract : list , a list of variants to include. exclude : list , a list of variants to exclude. id_use : string , specify which ID to use when merging with Hapmap3 SNPs. hapmap3 : boolean , if True, only output Hapmap3 SNPs. exclude_hla : boolean , if True, exclude variants in MHC region from output. build : string , reference genome build. xymt_number : if True, output chrX/Y/MT as 23/24/25. xymt : list , descript how to convert chromosome 23,24,25. chr_prefix : string , add a prefix to chromosomes when output chr. 6 -> Chr6. bgzip : boolean , if True, bgzip the output file. Only works for bed format. tabix : boolean , if True, use tabix to index the bgzipped output file. Only works for bed format. to_csvargs : dict , extra parameters for pd.to_csv() float_formats : dict , a dictionary to specify the float format for each column. verbose : boolean , if True, print logs. output_log : boolean , if True, save log to a file. Example 1: import gwaslab as gl # load your raw sumstats mysumstats = gl.Sumstats(...) # basic QC mysumstats.basic_check() # output metal format mysumstats.to_format(\"./test\",fmt=\"metal\") log : Tue Sep 13 18:00:41 2022 Start to format the output sumstats in: metal format Tue Sep 13 18:00:41 2022 -Formatting statistics ... Tue Sep 13 18:00:41 2022 - Float statistics formats: Tue Sep 13 18:00:41 2022 - Columns: ['EAF', 'BETA', 'SE', 'P'] Tue Sep 13 18:00:41 2022 - Output formats: ['{:.4g}', '{:.4f}', '{:.4f}', '{:.4e}'] Tue Sep 13 18:00:41 2022 - Start outputting sumstats in metal format... Tue Sep 13 18:00:41 2022 -metal format will be loaded... Tue Sep 13 18:00:41 2022 -metal format meta info: Tue Sep 13 18:00:41 2022 - format_name : metal Tue Sep 13 18:00:41 2022 - format_source : https://genome.sph.umich.edu/wiki/METAL_Documentation Tue Sep 13 18:00:41 2022 - format_version : 20220726 Tue Sep 13 18:00:41 2022 -gwaslab to metal format dictionary: Tue Sep 13 18:00:41 2022 - gwaslab keys: ['SNPID', 'EA', 'NEA', 'EAF', 'BETA', 'SE', 'P', 'DIRECTION'] Tue Sep 13 18:00:41 2022 - metal values: ['MarkerName', 'Allele1', 'Allele2', 'Freq1', 'Effect', 'StdErr', 'P-value', 'Direction'] Tue Sep 13 18:00:41 2022 -Output columns: Index(['MarkerName', 'Allele1', 'Allele2', 'Freq1', 'Effect', 'StdErr', 'P-value'], dtype='object') Tue Sep 13 18:00:41 2022 -Output path: ./test.metal.tsv.gz Tue Sep 13 18:00:41 2022 -Saving log file: ./test.metal.log Tue Sep 13 18:00:41 2022 Finished outputting successfully! Example 2: LDSC format, extract hapmap3 SNPs and exclude SNPs in HLA region ## format the sumstats to ldsc format ## extract only hapmap3 SNPs ## exclude SNPs in HLA region mysumstats.to_format(\"./test\",fmt=\"ldsc\", hapmap3=True, exclude_hla=False, build=\"19\") Example 3: bed-like format # output 1-based bed-like files for vep mysumstats.to_format(\"./test\",fmt=\"vep\",xymt_number=True,chr_prefix=\"Chr\") # output 0-based bed-like file, and then bgzip and index the file. mysumstats.to_format(\"./test\",fmt=\"bed\",bgzip=True,tabix=True) Example 4: vcf format # output vcf file, and then bgzip and index the file. mysumstats.to_format(\"./test\",fmt=\"vcf\",bgzip=True,tabix=True) Example 5: GWAS-ssf # output GWAS-ssf format mysumstats.to_format(\"./test\",fmt=\"ssf\") For sample codes, please check https://github.com/Cloufield/gwaslab/blob/main/examples/IO_format.ipynb","title":"Format & Save"},{"location":"Format/#output-sumstats-in-certain-formats","text":"to_format( path=\"./sumstats\", fmt=\"ldsc\", extract=None, exclude=None, id_use=\"rsID\", hapmap3=False, exclude_hla=False, build=\"19\", verbose=True, output_log=True, to_csvargs={}, float_formats={}, xymt_number=False, xymt=[\"X\",\"Y\",\"MT\"], chr_prefix=None, bgzip=False, tabix=False ) path : string , the path for the output, only prefix is needed. fmt =\"ldsc\": output format for sumstats. Currently support plink , plink2 , ldsc , saige , fastgwa , regenie . For details , please check https://github.com/Cloufield/formatbook . extract : list , a list of variants to include. exclude : list , a list of variants to exclude. id_use : string , specify which ID to use when merging with Hapmap3 SNPs. hapmap3 : boolean , if True, only output Hapmap3 SNPs. exclude_hla : boolean , if True, exclude variants in MHC region from output. build : string , reference genome build. xymt_number : if True, output chrX/Y/MT as 23/24/25. xymt : list , descript how to convert chromosome 23,24,25. chr_prefix : string , add a prefix to chromosomes when output chr. 6 -> Chr6. bgzip : boolean , if True, bgzip the output file. Only works for bed format. tabix : boolean , if True, use tabix to index the bgzipped output file. Only works for bed format. to_csvargs : dict , extra parameters for pd.to_csv() float_formats : dict , a dictionary to specify the float format for each column. verbose : boolean , if True, print logs. output_log : boolean , if True, save log to a file.","title":"Output sumstats in certain formats"},{"location":"Format/#example-1","text":"import gwaslab as gl # load your raw sumstats mysumstats = gl.Sumstats(...) # basic QC mysumstats.basic_check() # output metal format mysumstats.to_format(\"./test\",fmt=\"metal\") log : Tue Sep 13 18:00:41 2022 Start to format the output sumstats in: metal format Tue Sep 13 18:00:41 2022 -Formatting statistics ... Tue Sep 13 18:00:41 2022 - Float statistics formats: Tue Sep 13 18:00:41 2022 - Columns: ['EAF', 'BETA', 'SE', 'P'] Tue Sep 13 18:00:41 2022 - Output formats: ['{:.4g}', '{:.4f}', '{:.4f}', '{:.4e}'] Tue Sep 13 18:00:41 2022 - Start outputting sumstats in metal format... Tue Sep 13 18:00:41 2022 -metal format will be loaded... Tue Sep 13 18:00:41 2022 -metal format meta info: Tue Sep 13 18:00:41 2022 - format_name : metal Tue Sep 13 18:00:41 2022 - format_source : https://genome.sph.umich.edu/wiki/METAL_Documentation Tue Sep 13 18:00:41 2022 - format_version : 20220726 Tue Sep 13 18:00:41 2022 -gwaslab to metal format dictionary: Tue Sep 13 18:00:41 2022 - gwaslab keys: ['SNPID', 'EA', 'NEA', 'EAF', 'BETA', 'SE', 'P', 'DIRECTION'] Tue Sep 13 18:00:41 2022 - metal values: ['MarkerName', 'Allele1', 'Allele2', 'Freq1', 'Effect', 'StdErr', 'P-value', 'Direction'] Tue Sep 13 18:00:41 2022 -Output columns: Index(['MarkerName', 'Allele1', 'Allele2', 'Freq1', 'Effect', 'StdErr', 'P-value'], dtype='object') Tue Sep 13 18:00:41 2022 -Output path: ./test.metal.tsv.gz Tue Sep 13 18:00:41 2022 -Saving log file: ./test.metal.log Tue Sep 13 18:00:41 2022 Finished outputting successfully!","title":"Example 1:"},{"location":"Format/#example-2-ldsc-format-extract-hapmap3-snps-and-exclude-snps-in-hla-region","text":"## format the sumstats to ldsc format ## extract only hapmap3 SNPs ## exclude SNPs in HLA region mysumstats.to_format(\"./test\",fmt=\"ldsc\", hapmap3=True, exclude_hla=False, build=\"19\")","title":"Example 2: LDSC format, extract hapmap3 SNPs and exclude SNPs in HLA region"},{"location":"Format/#example-3-bed-like-format","text":"# output 1-based bed-like files for vep mysumstats.to_format(\"./test\",fmt=\"vep\",xymt_number=True,chr_prefix=\"Chr\") # output 0-based bed-like file, and then bgzip and index the file. mysumstats.to_format(\"./test\",fmt=\"bed\",bgzip=True,tabix=True)","title":"Example 3: bed-like format"},{"location":"Format/#example-4-vcf-format","text":"# output vcf file, and then bgzip and index the file. mysumstats.to_format(\"./test\",fmt=\"vcf\",bgzip=True,tabix=True)","title":"Example 4: vcf format"},{"location":"Format/#example-5-gwas-ssf","text":"# output GWAS-ssf format mysumstats.to_format(\"./test\",fmt=\"ssf\") For sample codes, please check https://github.com/Cloufield/gwaslab/blob/main/examples/IO_format.ipynb","title":"Example 5: GWAS-ssf"},{"location":"Gallery/","text":"","title":"Gallery"},{"location":"GeneticCorrelation/","text":"load data plot","title":"Heatmap: genetic correlation"},{"location":"Harmonization/","text":"Harmonization Methods summary Sumstats Methods Options Description .check_ref() ref_path check alignment with a reference sequence .rsid_to_chrpos() path, n_cores use rsid to fill CHR and POS .rsid_to_chrpos2() path use rsid to fill CHR and POS (muilti-thread, need hd5 file) .assign_rsid() path annotate rsid using a reference vcf file .infer_strand() ref_infer=\"\" , ref_alt_freq=None, maf_threshold=0.43 infer the strand of a variant using reference vcf file with EAF in INFO .check_daf() ref_infer=\"\" , ref_alt_freq=None, calculate difference in allele frequencies .flip_allele_stats() After alignment and inferring, flip the alleles to harmonise the variants. .liftover() n_cores=1,from_build=\"19\", to_build=\"38\" perform liftover Align NEA with REF in reference genome mysumstats.check_ref(ref_path=\"ref_genome.fa\") (! Only changing the status code) Check if NEA is aligned with the reference sequence. After checking, the tracking status code will be changed accordingly. Assign CHR and POS according to rsID and reference data mysumstats.rsid_to_chrpos() #single thread mysumstats.rsid_to_chrpos2() #multithread (to be tested) Assign rsID according to CHR, POS, REF/ALT mysumstats.assign_rsid(path=\"reference.vcf.gz\") Annotated variants with rsID using a reference vcf file (tabix indexd). Gwaslab will first extract all variants in reference file with matching CHR and POS. And then comapre EA/NEA in sumstats with REF/ALT in reference vcf. When matching, it will annotate the vairant in sumstats with the matching rsID in reference vcf. Check panlidromic SNPs or undistingushable Indels mysumstats.infer_strand() (! Only changing the status code) Infer the strand for palindromic SNPs (AT, or CG), the default threshlod is 0.43. make sure specify the right allele frequency for you target ancestry in INFO field. Checking the alignment status of indels with the REF allele in reference vcf file. Check difference in allele frequency mysumstats.check_daf() You may want to check the allele frequency discrepancy with a reference vcf. Just specify the path and the right allele frequency for you target ancestry in INFO field. GWASlab will simply calculate DAF = AF-EAF - AF-ALT , and store the results in DAF column. DAF can then be used to plot or filter variants. mysumstats.plot_daf() Flipping based on status code mysumstats.flip_allele_stats() Flip allele-specific statistics to harmonise the variants based on the tracking status code Liftover mysumstats.liftover(n_cores=1,from_build=\"19\", to_build=\"38\") Perform liftover for POS (based on liftover GitHub - jeremymcrae/liftover: liftover for python, made fast with cython )","title":"Harmonization"},{"location":"Harmonization/#harmonization","text":"","title":"Harmonization"},{"location":"Harmonization/#methods-summary","text":"Sumstats Methods Options Description .check_ref() ref_path check alignment with a reference sequence .rsid_to_chrpos() path, n_cores use rsid to fill CHR and POS .rsid_to_chrpos2() path use rsid to fill CHR and POS (muilti-thread, need hd5 file) .assign_rsid() path annotate rsid using a reference vcf file .infer_strand() ref_infer=\"\" , ref_alt_freq=None, maf_threshold=0.43 infer the strand of a variant using reference vcf file with EAF in INFO .check_daf() ref_infer=\"\" , ref_alt_freq=None, calculate difference in allele frequencies .flip_allele_stats() After alignment and inferring, flip the alleles to harmonise the variants. .liftover() n_cores=1,from_build=\"19\", to_build=\"38\" perform liftover","title":"Methods summary"},{"location":"Harmonization/#align-nea-with-ref-in-reference-genome","text":"mysumstats.check_ref(ref_path=\"ref_genome.fa\") (! Only changing the status code) Check if NEA is aligned with the reference sequence. After checking, the tracking status code will be changed accordingly.","title":"Align NEA with REF in reference genome"},{"location":"Harmonization/#assign-chr-and-pos-according-to-rsid-and-reference-data","text":"mysumstats.rsid_to_chrpos() #single thread mysumstats.rsid_to_chrpos2() #multithread (to be tested)","title":"Assign CHR and POS according to rsID and reference data"},{"location":"Harmonization/#assign-rsid-according-to-chr-pos-refalt","text":"mysumstats.assign_rsid(path=\"reference.vcf.gz\") Annotated variants with rsID using a reference vcf file (tabix indexd). Gwaslab will first extract all variants in reference file with matching CHR and POS. And then comapre EA/NEA in sumstats with REF/ALT in reference vcf. When matching, it will annotate the vairant in sumstats with the matching rsID in reference vcf.","title":"Assign rsID according to CHR, POS, REF/ALT"},{"location":"Harmonization/#check-panlidromic-snps-or-undistingushable-indels","text":"mysumstats.infer_strand() (! Only changing the status code) Infer the strand for palindromic SNPs (AT, or CG), the default threshlod is 0.43. make sure specify the right allele frequency for you target ancestry in INFO field. Checking the alignment status of indels with the REF allele in reference vcf file.","title":"Check panlidromic SNPs or undistingushable Indels"},{"location":"Harmonization/#check-difference-in-allele-frequency","text":"mysumstats.check_daf() You may want to check the allele frequency discrepancy with a reference vcf. Just specify the path and the right allele frequency for you target ancestry in INFO field. GWASlab will simply calculate DAF = AF-EAF - AF-ALT , and store the results in DAF column. DAF can then be used to plot or filter variants. mysumstats.plot_daf()","title":"Check difference in allele frequency"},{"location":"Harmonization/#flipping-based-on-status-code","text":"mysumstats.flip_allele_stats() Flip allele-specific statistics to harmonise the variants based on the tracking status code","title":"Flipping based on status code"},{"location":"Harmonization/#liftover","text":"mysumstats.liftover(n_cores=1,from_build=\"19\", to_build=\"38\") Perform liftover for POS (based on liftover GitHub - jeremymcrae/liftover: liftover for python, made fast with cython )","title":"Liftover"},{"location":"HeritabilityConversion/","text":"Heritabilty conversion (Observed-scale -> Liability-scale) gl.h2_obs_to_liab(h2_obs, P, K, se_obs=None) h2_obs : float. Heritability on the observed scale in an ascertained sample. P : float in (0,1). Prevalence of the phenotype in the sample. K : float in (0,1) . Prevalence of the phenotype in the population. se_obs : float. se of h2_obs. Adopted from LDSC. Reference: Estimating Missing Heritability for Disease from Genome-wide Association Studies https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3059431/","title":"Convert Heritability"},{"location":"HeritabilityConversion/#heritabilty-conversion-observed-scale-liability-scale","text":"gl.h2_obs_to_liab(h2_obs, P, K, se_obs=None) h2_obs : float. Heritability on the observed scale in an ascertained sample. P : float in (0,1). Prevalence of the phenotype in the sample. K : float in (0,1) . Prevalence of the phenotype in the population. se_obs : float. se of h2_obs. Adopted from LDSC. Reference: Estimating Missing Heritability for Disease from Genome-wide Association Studies https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3059431/","title":"Heritabilty conversion (Observed-scale -&gt; Liability-scale)"},{"location":"InferBuild/","text":"Infer Genome Build Version gwaslab use hapmaps chromosome and basepair position information to infer the reference genome build for sumstats. Status codes (first two digits) will be changed based on the results Example: mysumstats.infer_build() Wed Oct 19 11:01:01 2022 -Start to infer genome build version using hapmap3 SNPs... Wed Oct 19 11:01:01 2022 -Loading Hapmap3 variants data... Wed Oct 19 11:01:04 2022 -chr:pos will be used for matching... Wed Oct 19 11:01:33 2022 -Matching variants for hg19: num_hg19= 1092441 Wed Oct 19 11:01:33 2022 -Matching variants for hg38: num_hg38= 15997 Wed Oct 19 11:01:33 2022 -Since num_hg19>num_hg38, assigning genome build hg19...","title":"Infer Genome Build"},{"location":"InferBuild/#infer-genome-build-version","text":"gwaslab use hapmaps chromosome and basepair position information to infer the reference genome build for sumstats. Status codes (first two digits) will be changed based on the results Example: mysumstats.infer_build() Wed Oct 19 11:01:01 2022 -Start to infer genome build version using hapmap3 SNPs... Wed Oct 19 11:01:01 2022 -Loading Hapmap3 variants data... Wed Oct 19 11:01:04 2022 -chr:pos will be used for matching... Wed Oct 19 11:01:33 2022 -Matching variants for hg19: num_hg19= 1092441 Wed Oct 19 11:01:33 2022 -Matching variants for hg38: num_hg38= 15997 Wed Oct 19 11:01:33 2022 -Since num_hg19>num_hg38, assigning genome build hg19...","title":"Infer Genome Build Version"},{"location":"LiftOver/","text":"Liftover mysumstats.liftover(n_cores=3, from_build=\"19\", to_build=\"38\", remove=True) Options n_cores : number of threads to use for liftover from_build : from which genome build to_build : to which genome build remove : remove unmapped variants Perform liftover for POS (based on liftover GitHub - jeremymcrae/liftover: liftover for python, made fast with cython) example mysumstats = gl.Sumstats(\"t2d_bbj.txt.gz\", snpid=\"SNP\", chrom=\"CHR\", pos=\"POS\", ea=\"ALT\", nea=\"REF\", neaf=\"Frq\", beta=\"BETA\", se=\"SE\", p=\"P\",nrows=500000) mysumstats.basic_check() mysumstats.liftover(n_cores=3, from_build=\"19\", to_build=\"38\")","title":"Liftover"},{"location":"LiftOver/#liftover","text":"mysumstats.liftover(n_cores=3, from_build=\"19\", to_build=\"38\", remove=True)","title":"Liftover"},{"location":"LiftOver/#options","text":"n_cores : number of threads to use for liftover from_build : from which genome build to_build : to which genome build remove : remove unmapped variants Perform liftover for POS (based on liftover GitHub - jeremymcrae/liftover: liftover for python, made fast with cython)","title":"Options"},{"location":"LiftOver/#example","text":"mysumstats = gl.Sumstats(\"t2d_bbj.txt.gz\", snpid=\"SNP\", chrom=\"CHR\", pos=\"POS\", ea=\"ALT\", nea=\"REF\", neaf=\"Frq\", beta=\"BETA\", se=\"SE\", p=\"P\",nrows=500000) mysumstats.basic_check() mysumstats.liftover(n_cores=3, from_build=\"19\", to_build=\"38\")","title":"example"},{"location":"LoadLDSC/","text":"Batch load LDSC log file Simply batch load LDSc data into a pandas DataFrame for other manipulation. GWASLab uses regular expression to match the values and fill them into a dataframe. gl.read_ldsc() gl.read_ldsc(filelist, mode=\"h2\") `filelist` : a list of paths to ldsc log files `mode` : h2 or rg ```python #mode=h2 ldsc_file_list=[\"file1.\"] myldscrg = gl.read_ldsc(ldsc_file_list, mode=h2) #mode=rg ldsc_file_list=[\"file1.\"] myldscrg = gl.read_ldsc(mode=h2) pathlist=[\"./test.results.log\",\"./test2.results.log\"] ldsc_h2 = gl.read_ldsc(pathlist, mode=\"h2\") ldsc_rg = gl.read_ldsc(pathlist, mode=\"rg\") ldsc_h2 Filename h2_obs h2_se Lambda_gc Mean_chi2 Intercept Intercept_se Ratio Ratio_se test.results.log 42.9954 8.657 1.2899 1.3226 0.0098 0.0098 0.6538 0.0304 test2.results.log NA NA 1.2899 1.3226 0.0098 0.0098 Ratio < 0 NA ldsc_rg p1 p2 rg se z p h2_obs h2_obs_se h2_int h2_int_se gcov_int gcov_int_se ./test.results.log ./test.results.log 0.2317 0.0897 2.5824 0.0098 0.3305 0.0571 0.9612 0.009 -0.0001 0.0062 ./test.results.log ./test2.results.log 0.2317 0.0897 2.5824 0.0098 0.3305 0.0571 0.9612 0.009 -0.0001 0.0062 For genetic correlation, after loading, you can use gl.plot_rg() to plot a heat map to visualize the results. No extra manipulation needed. gl.plot_rg(myldscrg)","title":"Load LDSC log"},{"location":"LoadLDSC/#batch-load-ldsc-log-file","text":"Simply batch load LDSc data into a pandas DataFrame for other manipulation. GWASLab uses regular expression to match the values and fill them into a dataframe. gl.read_ldsc() gl.read_ldsc(filelist, mode=\"h2\") `filelist` : a list of paths to ldsc log files `mode` : h2 or rg ```python #mode=h2 ldsc_file_list=[\"file1.\"] myldscrg = gl.read_ldsc(ldsc_file_list, mode=h2) #mode=rg ldsc_file_list=[\"file1.\"] myldscrg = gl.read_ldsc(mode=h2) pathlist=[\"./test.results.log\",\"./test2.results.log\"] ldsc_h2 = gl.read_ldsc(pathlist, mode=\"h2\") ldsc_rg = gl.read_ldsc(pathlist, mode=\"rg\") ldsc_h2 Filename h2_obs h2_se Lambda_gc Mean_chi2 Intercept Intercept_se Ratio Ratio_se test.results.log 42.9954 8.657 1.2899 1.3226 0.0098 0.0098 0.6538 0.0304 test2.results.log NA NA 1.2899 1.3226 0.0098 0.0098 Ratio < 0 NA ldsc_rg p1 p2 rg se z p h2_obs h2_obs_se h2_int h2_int_se gcov_int gcov_int_se ./test.results.log ./test.results.log 0.2317 0.0897 2.5824 0.0098 0.3305 0.0571 0.9612 0.009 -0.0001 0.0062 ./test.results.log ./test2.results.log 0.2317 0.0897 2.5824 0.0098 0.3305 0.0571 0.9612 0.009 -0.0001 0.0062 For genetic correlation, after loading, you can use gl.plot_rg() to plot a heat map to visualize the results. No extra manipulation needed. gl.plot_rg(myldscrg)","title":"Batch load LDSC log file"},{"location":"MiamiPlot/","text":"Miami plot gl.plot_miami( path1, path2, cols1=[\"CHR\",\"POS\",\"P\"], cols2=[\"CHR\",\"POS\",\"P\"], sep=[\"\\t\",\"\\t\"], anno= None ) path1 : string path to sumstats1 path2 : string path to sumstats2 cols1 : list CHR,POS,P names for sumstats1 cols2 : list CHR,POS,P names for sumstats2 sep : list separator for each sumstats anno : boolean or GENENAME region : only plot a region. For example, region=(2,2153874,21753874) . highlight1 : list , list of loci to highlight for sumstats1. For example, highlight1=[(5,124289158)] . highlight2 : list , list of loci to highlight for sumstats2. pinpoint1 : list , list of variants to pinpolint for sumstats1. pinpoint2 : list , list of variants to pinpolint for sumstats2. titles : list , two titles. For example, titles=[\"male\",\"female\"] Example mysumstats = gl.plot_miami(path1=\"bmi_male_bbj.txt.gz\" , path2=\"bmi_female_bbj.txt.gz\", cols1=[\"CHR\",\"POS\",\"P\"], cols2=[\"CHR\",\"POS\",\"P\"], titles=[\"bmi male\",\"bmi female\"], titles_pad=[0.15,0.0], anno=\"GENENAME\", region_grid=True, highlight1=[(5,124289158)], pinpoint2=[(2,653874)] ) mysumstats = gl.plot_miami(path1=\"bmi_male_bbj.txt.gz\" , path2=\"bmi_female_bbj.txt.gz\", cols1=[\"CHR\",\"POS\",\"P\"], cols2=[\"CHR\",\"POS\",\"P\"], titles=[\"male\",\"female\"], region=(2,2153874,21753874), titles_pad=[0.1,-0.05], anno=\"GENENAME\", region_grid=True ) Note: implemented in v3.3.4","title":"Miami Plot"},{"location":"MiamiPlot/#miami-plot","text":"gl.plot_miami( path1, path2, cols1=[\"CHR\",\"POS\",\"P\"], cols2=[\"CHR\",\"POS\",\"P\"], sep=[\"\\t\",\"\\t\"], anno= None ) path1 : string path to sumstats1 path2 : string path to sumstats2 cols1 : list CHR,POS,P names for sumstats1 cols2 : list CHR,POS,P names for sumstats2 sep : list separator for each sumstats anno : boolean or GENENAME region : only plot a region. For example, region=(2,2153874,21753874) . highlight1 : list , list of loci to highlight for sumstats1. For example, highlight1=[(5,124289158)] . highlight2 : list , list of loci to highlight for sumstats2. pinpoint1 : list , list of variants to pinpolint for sumstats1. pinpoint2 : list , list of variants to pinpolint for sumstats2. titles : list , two titles. For example, titles=[\"male\",\"female\"]","title":"Miami plot"},{"location":"MiamiPlot/#example","text":"mysumstats = gl.plot_miami(path1=\"bmi_male_bbj.txt.gz\" , path2=\"bmi_female_bbj.txt.gz\", cols1=[\"CHR\",\"POS\",\"P\"], cols2=[\"CHR\",\"POS\",\"P\"], titles=[\"bmi male\",\"bmi female\"], titles_pad=[0.15,0.0], anno=\"GENENAME\", region_grid=True, highlight1=[(5,124289158)], pinpoint2=[(2,653874)] ) mysumstats = gl.plot_miami(path1=\"bmi_male_bbj.txt.gz\" , path2=\"bmi_female_bbj.txt.gz\", cols1=[\"CHR\",\"POS\",\"P\"], cols2=[\"CHR\",\"POS\",\"P\"], titles=[\"male\",\"female\"], region=(2,2153874,21753874), titles_pad=[0.1,-0.05], anno=\"GENENAME\", region_grid=True ) Note: implemented in v3.3.4","title":"Example"},{"location":"QC%26Filtering/","text":"QC and filtering Methods Summary Sumstats Methods Options Description .check_sanity() sanity check for statistics including BETA, SE, Z, CHISQ, EAF, OR, N... .remove_dup() mode=\"dm\",keep='first' remove duplicate or multi-allelic variants .filter_in() lt, gt, eq, inplace .filter_out() .filter_region_in() path , inplace=True ,high_ld=False, build=\"19\" .filter_region_out() path , inplace=True ,high_ld=False, build=\"19\" Statistics Sanity Check .check_sanity() : Basic sanity check will. be performed on statistics to check if there are any extreme values or values out of expected range . BETA/SE : float, -10<BETA<10, -10<log(OR)<10 OR/OR_95L/OR_95U : float, 0<OR<10, OR_95L>0, OR_95U>0 EAF : 0<= EAF <=1, if EAF of >95% of valid variants is less than 0.5, a warning will be sent. P : float, 0<P<5e-300 MLOG10 : float, MLOG10>0 Z : float CHISQ : float , CHISQ>0 N : interger, N>0 Direction : string, only contains \"+\",\"-\" ,\"0\"or \"?\" sumstats.check_sanity() Remove duplication or multiallelic variants after standardize the sumstats, you can also remove duplicated or multiallelic variants using : .remove_dup() mode: d ,remove duplicate. If SNPID exists, remove duplicate . If rsID exists, remove deuplicate rsID. m ,removed multiallelic. remove based on SNPID, CHR and POS sumstats.remove_dup(mode=\"dm\",keep='first') FIltering .filter_in(gt={},lt={},eq={},inplace=True) .filter_out(gt={},lt={},eq={},inplace=True) gt : greater than lt : less than eq : equal to inplace : True or False. If False, return a dataframe. If true, the Sumstats object will be filtered. Filtering region .filter_region_in(path=\"./abc.bed\") .filter_region_out(high_ld=True)","title":"QC&Filtering"},{"location":"QC%26Filtering/#qc-and-filtering","text":"","title":"QC and filtering"},{"location":"QC%26Filtering/#methods-summary","text":"Sumstats Methods Options Description .check_sanity() sanity check for statistics including BETA, SE, Z, CHISQ, EAF, OR, N... .remove_dup() mode=\"dm\",keep='first' remove duplicate or multi-allelic variants .filter_in() lt, gt, eq, inplace .filter_out() .filter_region_in() path , inplace=True ,high_ld=False, build=\"19\" .filter_region_out() path , inplace=True ,high_ld=False, build=\"19\"","title":"Methods Summary"},{"location":"QC%26Filtering/#statistics-sanity-check","text":".check_sanity() : Basic sanity check will. be performed on statistics to check if there are any extreme values or values out of expected range . BETA/SE : float, -10<BETA<10, -10<log(OR)<10 OR/OR_95L/OR_95U : float, 0<OR<10, OR_95L>0, OR_95U>0 EAF : 0<= EAF <=1, if EAF of >95% of valid variants is less than 0.5, a warning will be sent. P : float, 0<P<5e-300 MLOG10 : float, MLOG10>0 Z : float CHISQ : float , CHISQ>0 N : interger, N>0 Direction : string, only contains \"+\",\"-\" ,\"0\"or \"?\" sumstats.check_sanity()","title":"Statistics Sanity Check"},{"location":"QC%26Filtering/#remove-duplication-or-multiallelic-variants","text":"after standardize the sumstats, you can also remove duplicated or multiallelic variants using : .remove_dup() mode: d ,remove duplicate. If SNPID exists, remove duplicate . If rsID exists, remove deuplicate rsID. m ,removed multiallelic. remove based on SNPID, CHR and POS sumstats.remove_dup(mode=\"dm\",keep='first')","title":"Remove duplication or multiallelic variants"},{"location":"QC%26Filtering/#filtering","text":".filter_in(gt={},lt={},eq={},inplace=True) .filter_out(gt={},lt={},eq={},inplace=True) gt : greater than lt : less than eq : equal to inplace : True or False. If False, return a dataframe. If true, the Sumstats object will be filtered.","title":"FIltering"},{"location":"QC%26Filtering/#filtering-region","text":".filter_region_in(path=\"./abc.bed\") .filter_region_out(high_ld=True)","title":"Filtering region"},{"location":"Reference/","text":"Reference data for handling Sumstats Reference Library for variants annotation : pyensembl Install pyensembl and download reference: # install pyensembl if not pip install pyensembl # syntax for download reference for pyensembl pyensembl install --release <list of Ensembl release numbers> --species <species-name> GWASlab uses: - ensembl release 75 : hg19 - ensembl release 107 : hg38 - NCBI refseq GRCh37 - NCBI refseq GRCh38 Currently, gwaslab could use ensembl or refseq gtf reference data to annotate lead SNPs with the nearest gene name. For details about pyensembl, please check https://github.com/openvax/pyensembl Reference genome sequence for variant allele alignment GRCh37 / hg19 : ucsc_hg19 GRCh38 / hg38 : ucsc_hg38 For details about reference genome, please check https://cloufield.github.io/CTGCatalog/Reference_data_Genome_README/ Processed Reference files for harmonization 1000 Genome Project(hg19) Download: Index of /vol1/ftp/release/20130502/ Process the 1000 genome vcf file for EAS sample: Extract EAS sample Split multiallelic variants Normalize variants Rename variants as CHR:POS:REF:ALT Remove duplicated variants Calculate Alternative allele frequency Tabix index Sample code: #!/bin/bash # extract EAS sample ID awk '$3==\"EAS\"{print $1}' integrated_call_samples_v3.20130502.ALL.panel >EAS.sample # process for chr in {1..22} do bcftools view -S EAS.sample ALL.chr\"${chr}\".phase3_shapeit2_mvncall_integrated_v5a.20130502.genotypes.vcf.gz | \\ bcftools norm -m-any --check-ref w -f human_g1k_v37.fasta | \\ bcftools annotate -x ID,INFO -I +'%CHROM:%POS:%REF:%ALT' | \\ bcftools norm --rm-dup both | \\ bcftools +fill-tags -Oz -- -t AF \\ > EAS.chr\"${chr}\".split_norm_af.vcf.gz tabix -p vcf EAS.chr\"${chr}\".split_norm_af.vcf.gz echo \"EAS.chr\"${chr}\".split_norm_af.vcf.gz\" >>concat_list.txt done # merge bcftools concat -a -d both -f concat_list.txt -Ob | bcftools sort -Oz > EAS.ALL.split_norm_af.1kgp3v5.hg19.vcf.gz tabix -p vcf EAS.ALL.split_norm_af.1kgp3v5.hg19.vcf.gz The processed dataset can then be used for: infer palindromic SNPs / indels check allele frequency difference regional plot dbsnp: database for annoattion of rsID dbsnp v151 (hg19): https://ftp.ncbi.nih.gov/snp/organisms/human_9606_b151_GRCh37p13/VCF/00-All.vcf.gz latest release: Index of /snp/latest_release/VCF gnomad Allele frequency for major ancestries and rsID gnomAD v2 & gnomAD v2 liftover & gnomAD v3: gnomAD","title":"Reference data"},{"location":"Reference/#reference-data-for-handling-sumstats","text":"","title":"Reference data for handling Sumstats"},{"location":"Reference/#reference-library-for-variants-annotation-pyensembl","text":"Install pyensembl and download reference: # install pyensembl if not pip install pyensembl # syntax for download reference for pyensembl pyensembl install --release <list of Ensembl release numbers> --species <species-name> GWASlab uses: - ensembl release 75 : hg19 - ensembl release 107 : hg38 - NCBI refseq GRCh37 - NCBI refseq GRCh38 Currently, gwaslab could use ensembl or refseq gtf reference data to annotate lead SNPs with the nearest gene name. For details about pyensembl, please check https://github.com/openvax/pyensembl","title":"Reference Library for variants annotation : pyensembl"},{"location":"Reference/#reference-genome-sequence-for-variant-allele-alignment","text":"GRCh37 / hg19 : ucsc_hg19 GRCh38 / hg38 : ucsc_hg38 For details about reference genome, please check https://cloufield.github.io/CTGCatalog/Reference_data_Genome_README/","title":"Reference genome sequence for variant allele alignment"},{"location":"Reference/#processed-reference-files-for-harmonization","text":"","title":"Processed Reference files for harmonization"},{"location":"Reference/#1000-genome-projecthg19","text":"Download: Index of /vol1/ftp/release/20130502/ Process the 1000 genome vcf file for EAS sample: Extract EAS sample Split multiallelic variants Normalize variants Rename variants as CHR:POS:REF:ALT Remove duplicated variants Calculate Alternative allele frequency Tabix index","title":"1000 Genome Project(hg19)"},{"location":"Reference/#sample-code","text":"#!/bin/bash # extract EAS sample ID awk '$3==\"EAS\"{print $1}' integrated_call_samples_v3.20130502.ALL.panel >EAS.sample # process for chr in {1..22} do bcftools view -S EAS.sample ALL.chr\"${chr}\".phase3_shapeit2_mvncall_integrated_v5a.20130502.genotypes.vcf.gz | \\ bcftools norm -m-any --check-ref w -f human_g1k_v37.fasta | \\ bcftools annotate -x ID,INFO -I +'%CHROM:%POS:%REF:%ALT' | \\ bcftools norm --rm-dup both | \\ bcftools +fill-tags -Oz -- -t AF \\ > EAS.chr\"${chr}\".split_norm_af.vcf.gz tabix -p vcf EAS.chr\"${chr}\".split_norm_af.vcf.gz echo \"EAS.chr\"${chr}\".split_norm_af.vcf.gz\" >>concat_list.txt done # merge bcftools concat -a -d both -f concat_list.txt -Ob | bcftools sort -Oz > EAS.ALL.split_norm_af.1kgp3v5.hg19.vcf.gz tabix -p vcf EAS.ALL.split_norm_af.1kgp3v5.hg19.vcf.gz The processed dataset can then be used for: infer palindromic SNPs / indels check allele frequency difference regional plot","title":"Sample code:"},{"location":"Reference/#dbsnp-database-for-annoattion-of-rsid","text":"dbsnp v151 (hg19): https://ftp.ncbi.nih.gov/snp/organisms/human_9606_b151_GRCh37p13/VCF/00-All.vcf.gz latest release: Index of /snp/latest_release/VCF","title":"dbsnp: database for annoattion of rsID"},{"location":"Reference/#gnomad","text":"Allele frequency for major ancestries and rsID gnomAD v2 & gnomAD v2 liftover & gnomAD v3: gnomAD","title":"gnomad"},{"location":"RegionalPlot/","text":"Regional plot: mqqplot( vcf_path=None, vcf_chr_dict=get_number_to_chr(), gtf_path=\"defualt\", mlog10p=\"MLOG10P\", scaled=False, mode=\"r\", # region region = None, region_step = 21, region_grid = False, region_grid_line = {\"linewidth\": 2,\"linestyle\":\"--\"}, region_lead_grid = True, region_lead_grid_line = {\"alpha\":0.5,\"linewidth\" : 2,\"linestyle\":\"--\",\"color\":\"#FF0000\"}, region_hspace=0.02, region_ld_threshold = [0.2,0.4,0.6,0.8], region_ld_colors = [\"#E4E4E4\",\"#020080\",\"#86CEF9\",\"#24FF02\",\"#FDA400\",\"#FF0000\",\"#FF0000\"], region_recombination = True, region_protein_coding=True, region_flank_factor = 0.05, taf=[4,0,0.95,1,1], # track_n, track_n_offset,font_ratio,exon_ratio,text_offset mqqratio=3, windowsizekb=500, anno=None, anno_set=[], anno_alias={}, anno_d={}, anno_source = \"ensembl\", arm_offset=50, arm_scale=1, cut=0, skip=0, cutfactor=10, cut_line_color=\"#ebebeb\", sig_level=5e-8, sig_line_color=\"grey\", suggestive_sig_level=5e-6, highlight = [], highlight_color=\"#CB132D\", highlight_windowkb = 500, pinpoint=[], pinpoint_color =\"red\", stratified=False, maf_bins=[(0, 0.01), (0.01, 0.05), (0.05, 0.25),(0.25,0.5)], maf_bin_colors = [\"#f0ad4e\",\"#5cb85c\", \"#5bc0de\",\"#000042\"], gc=True, title =None, mtitle=None, qtitle=None, figargs= {\"figsize\":(15,5),\"dpi\":100}, fontsize = 10, colors=[\"#597FBD\",\"#74BAD3\"], marker_size=(5,25), use_rank=False, verbose=True, repel_force=0.03, build=\"19\", title_pad=1.08, save=None, saveargs={\"dpi\":400,\"facecolor\":\"white\"}, log=Log() ): gwaslab regional plot function is based on plot_mqq(). Regional mqq plot !wget -O t2d_bbj.txt.gz http://jenger.riken.jp/14/ mysumstats = gl.Sumstats(\"t2d_bbj.txt.gz\", snpid=\"SNP\", chrom=\"CHR\", pos=\"POS\", neaf=\"Frq\", p=\"P\") mysumstats.plot_mqq(region=(7,156538803,157538803)) Regional plot without LD mysumstats.plot_mqq(mode=\"r\", region=(7,156538803,157538803),region_grid=True) Regional plot mysumstats.plot_mqq(mode=\"r\",region=(7,156538803,157538803),region_grid=True, vcf_path=\"/home/yunye/mydata/d_disk/eas_1kg_af/EAS.chr7.split_norm_af.vcf.gz\")","title":"Regional Plot"},{"location":"RegionalPlot/#regional-plot","text":"mqqplot( vcf_path=None, vcf_chr_dict=get_number_to_chr(), gtf_path=\"defualt\", mlog10p=\"MLOG10P\", scaled=False, mode=\"r\", # region region = None, region_step = 21, region_grid = False, region_grid_line = {\"linewidth\": 2,\"linestyle\":\"--\"}, region_lead_grid = True, region_lead_grid_line = {\"alpha\":0.5,\"linewidth\" : 2,\"linestyle\":\"--\",\"color\":\"#FF0000\"}, region_hspace=0.02, region_ld_threshold = [0.2,0.4,0.6,0.8], region_ld_colors = [\"#E4E4E4\",\"#020080\",\"#86CEF9\",\"#24FF02\",\"#FDA400\",\"#FF0000\",\"#FF0000\"], region_recombination = True, region_protein_coding=True, region_flank_factor = 0.05, taf=[4,0,0.95,1,1], # track_n, track_n_offset,font_ratio,exon_ratio,text_offset mqqratio=3, windowsizekb=500, anno=None, anno_set=[], anno_alias={}, anno_d={}, anno_source = \"ensembl\", arm_offset=50, arm_scale=1, cut=0, skip=0, cutfactor=10, cut_line_color=\"#ebebeb\", sig_level=5e-8, sig_line_color=\"grey\", suggestive_sig_level=5e-6, highlight = [], highlight_color=\"#CB132D\", highlight_windowkb = 500, pinpoint=[], pinpoint_color =\"red\", stratified=False, maf_bins=[(0, 0.01), (0.01, 0.05), (0.05, 0.25),(0.25,0.5)], maf_bin_colors = [\"#f0ad4e\",\"#5cb85c\", \"#5bc0de\",\"#000042\"], gc=True, title =None, mtitle=None, qtitle=None, figargs= {\"figsize\":(15,5),\"dpi\":100}, fontsize = 10, colors=[\"#597FBD\",\"#74BAD3\"], marker_size=(5,25), use_rank=False, verbose=True, repel_force=0.03, build=\"19\", title_pad=1.08, save=None, saveargs={\"dpi\":400,\"facecolor\":\"white\"}, log=Log() ): gwaslab regional plot function is based on plot_mqq().","title":"Regional plot:"},{"location":"RegionalPlot/#regional-mqq-plot","text":"!wget -O t2d_bbj.txt.gz http://jenger.riken.jp/14/ mysumstats = gl.Sumstats(\"t2d_bbj.txt.gz\", snpid=\"SNP\", chrom=\"CHR\", pos=\"POS\", neaf=\"Frq\", p=\"P\") mysumstats.plot_mqq(region=(7,156538803,157538803))","title":"Regional mqq plot"},{"location":"RegionalPlot/#regional-plot-without-ld","text":"mysumstats.plot_mqq(mode=\"r\", region=(7,156538803,157538803),region_grid=True)","title":"Regional plot without LD"},{"location":"RegionalPlot/#regional-plot_1","text":"mysumstats.plot_mqq(mode=\"r\",region=(7,156538803,157538803),region_grid=True, vcf_path=\"/home/yunye/mydata/d_disk/eas_1kg_af/EAS.chr7.split_norm_af.vcf.gz\")","title":"Regional plot"},{"location":"Standardization/","text":"Standardization and normalization import gwaslab as gl sumstats = gl.Sumstats(...) After loading raw sumstats into gwaslab Sumstats Object, the first thing we probably want to do is to standardize the variant-related notations and check if there are any unexpected errors in the statistics. When checking is finished, the status code will be automatically changed. Methods Summary Sumstats Methods Options Description .fix_ID() fixchrpos=False , fixid=False , overwrite=False check and fix rsID or SNPID(chr:pos:ref:alt), or use snpid to fix CHR and POS .fix_CHR() remove=False standardize chromsome notation .fix_POS() remove=False standardize basepair posituion notation and filter out bad values .fix_allele() remove=False standardize base notation to ATCG .normalize_allele() n_cores=1 normalize indels (only support ATA:AA -> AT:A but not -:T) .sort_coordinate() sort the variant coordinates 1. IDs Gwaslab requires at least one ID columns for sumstats, either in the form of SNPID or rsID, (or both). Gwaslab will automatically check if SNPID is mixed in rsID. SNPID : it could be user provided IDs, or in CHR:POS:REF:ALT format, delimiter can be\":\",\"_\" or \"-\" rsID : dbSNP rsIDs gwaslab checks if the IDs you provided is valid SNPID or rsID. It can also extract CHR and POS information from the CHR:POS:REF:ALT formatted IDs using .fix_ID() method. SNPID will be fixed by CHR:POS:NEA:EA only when the variants is already aligned with reference genome. Otherwise, a temporary SNPID in the format of CHR:POS will be given. .fix_ID() : check or fix SNPID and rsID. sumstats.fixID(fixchrpos=False, fixid=False, overwrite=False) 2. CHR .fix_CHR() CHR will be standardized to 1-22,X,Y,MT Leading \"chr\" and leading 0s will be stripped. sumstats.fix_CHR(remove=False) 3. POS .fix_POS() Values in POS must be positive integer numbers. Basepair position will be force converted to integers. Invalid pos will be converted to NA. (not implemented yet) After conversion, gwaslab will also sanity check if POS is in the range of 1 to 300,000,000. (the longest chromosome, CHR1, is around 250,000,000bp long) sumstats.fix_POS(remove=False) 4. Allele 4.1 Standardization .fix_allele() Currently, gwaslab only support processing SNPs and INDELs. All alleles will be checked if containing letters other than ATCG . Copy number variant (CNV) like <CN0> won't be recognized. Lower cases will converted to UPPERCASES. sumstats.fix_allele(remove=False) 4.2 Normalization .normalize_allele() Alleles will be normalized accroding to left alignment and parsimony principal. (For details: add link here ) For example, chr1:123456:ATG:AT will be normalized to chr1:123455:TG:T. Note: Currently, the normalizeation is implemented without checking reference, which means it can not normalize variants like chr1:123456:G:- if the missing information need to be obtained from a reference genome. sumstats.normalize_allele(n_cores=1) 5. Coordinate sorting Sort genomic coordinates\uff0c 1-22 X Y MT sumstats.sort_coordinate() 6. Column sorting The default column order is \"SNPID\",\"rsID\", \"CHR\", \"POS\", \"EA\", \"NEA\", \"EAF\", \"BETA\", \"SE\", \"Z\", \"CHISQ\", \"P\", \"MLOG10P\", \"OR\", \"OR_SE\", \"OR_95L\", \"OR_95U\", \"INFO\", \"N\",\"DIRECTION\",\"STATUS\" and other additional columns. sumstats.sort_columns()","title":"Standardization&normalization"},{"location":"Standardization/#standardization-and-normalization","text":"import gwaslab as gl sumstats = gl.Sumstats(...) After loading raw sumstats into gwaslab Sumstats Object, the first thing we probably want to do is to standardize the variant-related notations and check if there are any unexpected errors in the statistics. When checking is finished, the status code will be automatically changed.","title":"Standardization and normalization"},{"location":"Standardization/#methods-summary","text":"Sumstats Methods Options Description .fix_ID() fixchrpos=False , fixid=False , overwrite=False check and fix rsID or SNPID(chr:pos:ref:alt), or use snpid to fix CHR and POS .fix_CHR() remove=False standardize chromsome notation .fix_POS() remove=False standardize basepair posituion notation and filter out bad values .fix_allele() remove=False standardize base notation to ATCG .normalize_allele() n_cores=1 normalize indels (only support ATA:AA -> AT:A but not -:T) .sort_coordinate() sort the variant coordinates","title":"Methods Summary"},{"location":"Standardization/#1-ids","text":"Gwaslab requires at least one ID columns for sumstats, either in the form of SNPID or rsID, (or both). Gwaslab will automatically check if SNPID is mixed in rsID. SNPID : it could be user provided IDs, or in CHR:POS:REF:ALT format, delimiter can be\":\",\"_\" or \"-\" rsID : dbSNP rsIDs gwaslab checks if the IDs you provided is valid SNPID or rsID. It can also extract CHR and POS information from the CHR:POS:REF:ALT formatted IDs using .fix_ID() method. SNPID will be fixed by CHR:POS:NEA:EA only when the variants is already aligned with reference genome. Otherwise, a temporary SNPID in the format of CHR:POS will be given. .fix_ID() : check or fix SNPID and rsID. sumstats.fixID(fixchrpos=False, fixid=False, overwrite=False)","title":"1. IDs"},{"location":"Standardization/#2-chr","text":".fix_CHR() CHR will be standardized to 1-22,X,Y,MT Leading \"chr\" and leading 0s will be stripped. sumstats.fix_CHR(remove=False)","title":"2. CHR"},{"location":"Standardization/#3-pos","text":".fix_POS() Values in POS must be positive integer numbers. Basepair position will be force converted to integers. Invalid pos will be converted to NA. (not implemented yet) After conversion, gwaslab will also sanity check if POS is in the range of 1 to 300,000,000. (the longest chromosome, CHR1, is around 250,000,000bp long) sumstats.fix_POS(remove=False)","title":"3. POS"},{"location":"Standardization/#4-allele","text":"","title":"4. Allele"},{"location":"Standardization/#41-standardization","text":".fix_allele() Currently, gwaslab only support processing SNPs and INDELs. All alleles will be checked if containing letters other than ATCG . Copy number variant (CNV) like <CN0> won't be recognized. Lower cases will converted to UPPERCASES. sumstats.fix_allele(remove=False)","title":"4.1 Standardization"},{"location":"Standardization/#42-normalization","text":".normalize_allele() Alleles will be normalized accroding to left alignment and parsimony principal. (For details: add link here ) For example, chr1:123456:ATG:AT will be normalized to chr1:123455:TG:T. Note: Currently, the normalizeation is implemented without checking reference, which means it can not normalize variants like chr1:123456:G:- if the missing information need to be obtained from a reference genome. sumstats.normalize_allele(n_cores=1)","title":"4.2 Normalization"},{"location":"Standardization/#5-coordinate-sorting","text":"Sort genomic coordinates\uff0c 1-22 X Y MT sumstats.sort_coordinate()","title":"5. Coordinate sorting"},{"location":"Standardization/#6-column-sorting","text":"The default column order is \"SNPID\",\"rsID\", \"CHR\", \"POS\", \"EA\", \"NEA\", \"EAF\", \"BETA\", \"SE\", \"Z\", \"CHISQ\", \"P\", \"MLOG10P\", \"OR\", \"OR_SE\", \"OR_95L\", \"OR_95U\", \"INFO\", \"N\",\"DIRECTION\",\"STATUS\" and other additional columns. sumstats.sort_columns()","title":"6. Column sorting"},{"location":"StatusCode/","text":"Status Code A 7-digit code: showing the status of a variants. Reflecting the reliability of the statistics. Design principals: Tracable Higher value ->higer uncertainty Digit Description 1,2 Genome_build 3 rsID & SNPID 4 CHR, POS 5 EA, NEA 6 REF-NEA Alignment 7 Palindromic SNPs + Indels Reference table","title":"StatusCode"},{"location":"StatusCode/#status-code","text":"A 7-digit code: showing the status of a variants. Reflecting the reliability of the statistics. Design principals: Tracable Higher value ->higer uncertainty Digit Description 1,2 Genome_build 3 rsID & SNPID 4 CHR, POS 5 EA, NEA 6 REF-NEA Alignment 7 Palindromic SNPs + Indels","title":"Status Code"},{"location":"StatusCode/#reference-table","text":"","title":"Reference table"},{"location":"SumstatsObject/","text":"Sumstats Object in gwaslab In gwaslab, sumstats were stored in a Sumstats Object \uff0cwhich is built on pandas Dataframe . All other function are designed as methods of this Sumstats Object. To load any sumstats into the object, simply specify the column name and load the raw GWAS summary statsitics from a pandas dataframe or specifying file path. All raw data will be loaded as \"string\" datatype. mysumstats = gl.Sumstats( sumstats, fmt=None, snpid=None, rsid=None, chrom=None, pos=None, ea=None, nea=None, eaf=None, n=None, beta=None, se=None, chisq=None, z=None, p=None, mlog10p=None, info=None, OR=None, OR_95L=None, OR_95U=None, status=None, other=[], direction=None, verbose=True, build=\"00\", **args ) sumstats : either a file path or a pandas DataFrame Currently, gwaslab supports the following columns: snpid : variant ID column name, preferably in chr:pos:ea:nea format. rsid : dbSNP rsID column name The minimum required columns are just either rsid or snpid . All other columns are optional. fmt : input sumstats format : For formats supported by gwaslab, please check https://github.com/Cloufield/formatbook chrom : chromosome column name pos : basepair position column name ea : effect allele column name nea : non-effect allele column name eaf : effect allele frequency n : sample size column name or just input a single integer beta : effect size beta column name se : standard error column name chisq : chi square column name z : z score column name p : p value column name mlog10p : -log10(P) column name info : imputation info or rsq column name OR : odds ratio column name OR_95L :odds ratio lower 95% ci column name OR_95U :odds ratio upper 95% ci column name direction : direction column name in METAL format (e.g. \"++--+?+\") other : a list of other column names you want to keep with the core columns, probably some annotations. status : gwaslab 7-digit vairants status code. For details, please check status code page. verbose : if true: output log build : str genome build (\"19\",\"38\") **arg : additional parameters for pd.read_table() function. Loading sumstats you can load the path by specifying the columns like: mysumstats = gl.Sumstats(\"t2d_bbj.txt.gz\", snpid=\"SNPID\", chrom=\"CHR\", pos=\"POS\", ea=\"Allele2\", nea=\"Allele1\", eaf=\"AF_Allele2\", beta=\"BETA\", se=\"SE\", p=\"p.value\", n=\"N\") or just specify the format: mysumstats = gl.Sumstats(\"t2d_bbj.txt.gz\", format=\"saige\") gwaslab uses manully curated format conversion dictionary in https://github.com/Cloufield/formatbook Supported formats: ssf : GWAS-SSF gwascatalog : GWAS Catalog format pgscatalog : PGS Catalog format plink : PLINK output format plink2 : PLINK2 output format saige : SAIGE output format regenie : output format fastgwa : output format metal : output format mrmega : output format fuma : input format ldsc : input format locuszoom : input format vcf : gwas-vcf format Check and save sumstats After loading, the raw data columns will be renamed to new columns without ambiguity and the dataframe is store in .data : mysumstats.data You can simply save the processed data using pandas saving functions, for example mysumstats.data.to_csv(\"./mysumstats.csv\") or convert the sumstats to other sumstats using gwaslab to_format() function: mysumstats.to_format(\"./mysumstats\", fmt=\"ldsc\",hapmap3=True, exclude_hla=True, build=\"19\") Please check https://cloufield.github.io/gwaslab/Format/ Logging All manipulation conducted to the sumstats will be logged for reproducibility and traceability. The log is stored in a gl.Log object . You can check it by .log.show() and save it using .log.save() mysumstats.log.show() mysumstats.log.save() Sumstats summary You can check the meta information of this sumstats by: mysumstats.summary() Other functions Other functions of gwaslab is implemented as the methods of Sumstats Object. mysumstats.basic_check() mysumstats.plot_mqq() ...","title":"SumstatsObject"},{"location":"SumstatsObject/#sumstats-object-in-gwaslab","text":"In gwaslab, sumstats were stored in a Sumstats Object \uff0cwhich is built on pandas Dataframe . All other function are designed as methods of this Sumstats Object. To load any sumstats into the object, simply specify the column name and load the raw GWAS summary statsitics from a pandas dataframe or specifying file path. All raw data will be loaded as \"string\" datatype. mysumstats = gl.Sumstats( sumstats, fmt=None, snpid=None, rsid=None, chrom=None, pos=None, ea=None, nea=None, eaf=None, n=None, beta=None, se=None, chisq=None, z=None, p=None, mlog10p=None, info=None, OR=None, OR_95L=None, OR_95U=None, status=None, other=[], direction=None, verbose=True, build=\"00\", **args ) sumstats : either a file path or a pandas DataFrame Currently, gwaslab supports the following columns: snpid : variant ID column name, preferably in chr:pos:ea:nea format. rsid : dbSNP rsID column name The minimum required columns are just either rsid or snpid . All other columns are optional. fmt : input sumstats format : For formats supported by gwaslab, please check https://github.com/Cloufield/formatbook chrom : chromosome column name pos : basepair position column name ea : effect allele column name nea : non-effect allele column name eaf : effect allele frequency n : sample size column name or just input a single integer beta : effect size beta column name se : standard error column name chisq : chi square column name z : z score column name p : p value column name mlog10p : -log10(P) column name info : imputation info or rsq column name OR : odds ratio column name OR_95L :odds ratio lower 95% ci column name OR_95U :odds ratio upper 95% ci column name direction : direction column name in METAL format (e.g. \"++--+?+\") other : a list of other column names you want to keep with the core columns, probably some annotations. status : gwaslab 7-digit vairants status code. For details, please check status code page. verbose : if true: output log build : str genome build (\"19\",\"38\") **arg : additional parameters for pd.read_table() function.","title":"Sumstats Object in gwaslab"},{"location":"SumstatsObject/#loading-sumstats","text":"you can load the path by specifying the columns like: mysumstats = gl.Sumstats(\"t2d_bbj.txt.gz\", snpid=\"SNPID\", chrom=\"CHR\", pos=\"POS\", ea=\"Allele2\", nea=\"Allele1\", eaf=\"AF_Allele2\", beta=\"BETA\", se=\"SE\", p=\"p.value\", n=\"N\") or just specify the format: mysumstats = gl.Sumstats(\"t2d_bbj.txt.gz\", format=\"saige\") gwaslab uses manully curated format conversion dictionary in https://github.com/Cloufield/formatbook Supported formats: ssf : GWAS-SSF gwascatalog : GWAS Catalog format pgscatalog : PGS Catalog format plink : PLINK output format plink2 : PLINK2 output format saige : SAIGE output format regenie : output format fastgwa : output format metal : output format mrmega : output format fuma : input format ldsc : input format locuszoom : input format vcf : gwas-vcf format","title":"Loading sumstats"},{"location":"SumstatsObject/#check-and-save-sumstats","text":"After loading, the raw data columns will be renamed to new columns without ambiguity and the dataframe is store in .data : mysumstats.data You can simply save the processed data using pandas saving functions, for example mysumstats.data.to_csv(\"./mysumstats.csv\") or convert the sumstats to other sumstats using gwaslab to_format() function: mysumstats.to_format(\"./mysumstats\", fmt=\"ldsc\",hapmap3=True, exclude_hla=True, build=\"19\") Please check https://cloufield.github.io/gwaslab/Format/","title":"Check and save sumstats"},{"location":"SumstatsObject/#logging","text":"All manipulation conducted to the sumstats will be logged for reproducibility and traceability. The log is stored in a gl.Log object . You can check it by .log.show() and save it using .log.save() mysumstats.log.show() mysumstats.log.save()","title":"Logging"},{"location":"SumstatsObject/#sumstats-summary","text":"You can check the meta information of this sumstats by: mysumstats.summary()","title":"Sumstats summary"},{"location":"SumstatsObject/#other-functions","text":"Other functions of gwaslab is implemented as the methods of Sumstats Object. mysumstats.basic_check() mysumstats.plot_mqq() ...","title":"Other functions"},{"location":"Tutorial/","text":"Quick Start import gwaslab and load data Using a jupyter notebook, we first import gwaslab package: import gwaslab as gl The sample sumstats we use in this study: !wget -O t2d_bbj.txt.gz http://jenger.riken.jp/14/ Let's import this raw sumstats into the gwaslab Sumstats Object by specifying the necessary columns, and all data are imported as strings. Note: you can either specify eaf (effect allele frequency) or neaf(non-effect allele frequency), if neaf is specified, it will be converted to eaf when loading sumstats. mysumstats = gl.Sumstats(\"t2d_bbj.txt.gz\", snpid=\"SNP\", chrom=\"CHR\", pos=\"POS\", ea=\"ALT\", nea=\"REF\", neaf=\"Frq\", beta=\"BETA\", se=\"SE\", p=\"P\", direction=\"Dir\", n=\"N\", build=\"19\") See details in SumstatsObject . Sumstats are loaded stored as pandas DataFrame, you can check the data by mysumstats.data SNPID CHR POS EA NEA EAF BETA SE P N DIRECTION STATUS 0 1:725932_G_A 1 725932 G A 0.9960 -0.0737 0.1394 0.5970 166718 -?+- 9999999 1 1:725933_A_G 1 725933 G A 0.0040 0.0737 0.1394 0.5973 166718 +?-+ 9999999 2 1:737801_T_C 1 737801 C T 0.0051 0.0490 0.1231 0.6908 166718 +?-+ 9999999 3 1:749963_T_TAA 1 749963 TAA T 0.8374 0.0213 0.0199 0.2846 166718 -?++ 9999999 4 1:751343_T_A 1 751343 T A 0.8593 0.0172 0.0156 0.2705 166718 -?++ 9999999 Maybe the first thing you want to check is the manhattan plot, you can do this with one line of code, gwaslab will perform a minimum QC for just the plotting. For details, please check: https://cloufield.github.io/gwaslab/Visualization/ quick mqq plot mysumstats.plot_mqq(skip=2) skip=2 : skip variants with -log10P<2 for plotting, which greatly improves plotting speed. Standardization & normalization It is needed to check ID,CHR,POS and alleles first before any manipulations: Simply run the following function and every thing will be checked. mysumstats.basic_check() .basic_check() is a wrapper of all the following basic functions, you can use these separately. mysumstats.fix_ID() mysumstats.fix_chr() mysumstats.fix_pos() mysumstats.fix_allele() mysumstats.check_sanity() mysumstats.normalize_allele() See details in Standardization . Fix ID Usually we want SNPID to be in a stadardized format chr:pos:ref:alt, we can use fix_id for this: mysumstats.fix_id(fixsep=True) Extract lead variants Let's extract the lead variants in each significant loci to check our data. The significant loci are detected based on a sliding window (default window size: 500kb) mysumstats.get_lead(anno=True) By specifying anno=True , gwaslab will also annotate the lead variant with its nearest gene names and distance. Note : gwaslab default genome build version is build=\"19\" (GRCh37/hg19), you can change it to build=\"38\" (GRCh38/hg38) when needed. SNPID CHR POS EA NEA EAF BETA SE P N DIRECTION STATUS LOCATION GENE 96739 1:22068326:A:G 1 22068326 G A 0.7550 0.0621 0.0103 1.629000e-09 191764 ++++ 9960099 0 USP48 213860 1:51103268:T:C 1 51103268 C T 0.7953 -0.0802 0.0120 2.519000e-11 191764 ---- 9960099 0 FAF1 534095 1:154309595:TA:T 1 154309595 TA T 0.0947 -0.0915 0.0166 3.289000e-08 191764 ---- 9960399 0 ATP8B2 969974 2:640986:CACAT:C 2 640986 C CACAT 0.9006 -0.0946 0.0150 2.665000e-10 191764 ---- 9960399 26349 TMEM18 1091807 2:27734972:G:A 2 27734972 G A 0.5605 0.0691 0.0088 3.897000e-15 191764 ++++ 9960099 0 GCKR See details in ExtractLead . Customized manhattan plot GWASlab can plot more complicated manhattan plot. For details, please check: https://cloufield.github.io/gwaslab/Visualization/ mysumstats.plot_mqq(snpid=\"SNPID\",mode=\"mqq\", cut=20,skip=3, eaf=\"EAF\", anno=True,anno_set=[\"9:22132729_A_G\",\"6:20688121_T_A\",\"9:22132729_A_G\",\"15:62394264_G_C\"] , pinpoint=[\"9:22132729_A_G\",\"5:176513896_C_A\"], highlight=[\"7:127253550_C_T\",\"19:46166604_C_T\"], highlight_windowkb =1000, stratified=True, marker_size=(5,10), figargs={\"figsize\":(15,5),\"dpi\":300}) See details in Visualization . Regional plot Quick regional plot without LD-information mysumstats.plot_mqq(mode=\"r\",region=(7,156538803,157538803),region_grid=True) Note : gwaslab default genome build version is build=\"19\" (GRCh37/hg19), you can change it to build=\"38\" (GRCh38/hg38) when needed. For gene tracks, default is gtf_path=\"ensembl\" , you can also use gtf_path=\"refseq\" (NCBA RefSeq) Full regional plot using a user-provided vcf (e.g 1000 genome, see Reference: https://cloufield.github.io/gwaslab/Reference/) ) mysumstats.plot_mqq(mode=\"r\",region=(7,156538803,157538803),region_grid=True,anno=True, vcf_path=\"/Users/he/Documents/Mydata/eas_1kg_af/EAS.chr7.split_norm_af.1kgp3v5.vcf.gz\") Random sampling There are more than 10 million variants in the original sumstats and it will take long to process the entrie dataset. Since it might take a while to process the entire datasets, let us just random sample 1 million variants for this tutorial. mysumstats.random_variants(n=100000) Harmonise the sumstats ref_seq : reference genome fasta file for allele alignment ref_rsid_tsv : tsv file for annotation of common used variants ref_rsid_vcf : vcf file for annotation of other variants ref_infer : vcf file with allele frequency information for inferring strand and comparing allele frequency ref_alt_freq : field in INFO of vcf file for alternative allele frequency For details see: https://cloufield.github.io/gwaslab/Harmonization/ mysumstats.harmonize(basic_check=False, n_cores=3, ref_seq=\"/Users/he/Documents/Mydata/human_g1k_v37.fasta\", ref_rsid_tsv=\"/Users/he/Documents/Mydata/EAS_1kg_af_dbsnp151.ALL.tsv\", ref_rsid_vcf=\"/Users/he/Documents/Mydata/All_20180423.vcf.gz\", ref_infer=\"/Users/he/Documents/Mydata/eas_1kg_af/EAS.ALL.split_norm_af.1kgp3v5.hg19.vcf.gz\",ref_alt_freq=\"AF\") gwaslab will then harmonize the sumstats based on reference files. Fri Oct 21 16:05:39 2022 Start to check if NEA is aligned with reference sequence... Fri Oct 21 16:05:39 2022 -Current Dataframe shape : 100000 x 12 Fri Oct 21 16:05:39 2022 -Reference genome fasta file: /Users/he/Documents/Mydata/human_g1k_v37.fasta Fri Oct 21 16:05:39 2022 -Checking records: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 X Y MT Fri Oct 21 16:06:11 2022 -Variants allele on given reference sequence : 41646 Fri Oct 21 16:06:11 2022 -Variants flipped : 50095 Fri Oct 21 16:06:11 2022 -Raw Matching rate : 91.74% Fri Oct 21 16:06:11 2022 -Variants inferred reverse_complement : 0 Fri Oct 21 16:06:11 2022 -Variants inferred reverse_complement_flipped : 0 Fri Oct 21 16:06:11 2022 -Both allele on genome + unable to distinguish : 8259 Fri Oct 21 16:06:11 2022 -Variants not on given reference sequence : 0 Fri Oct 21 16:06:11 2022 -Current Dataframe shape : 100000 x 12 Fri Oct 21 16:06:12 2022 Start to flip allele-specific stats for SNPs with status xxxxx[35]x: alt->ea , ref->nea ... Fri Oct 21 16:06:12 2022 -Flipping 50095 variants... Fri Oct 21 16:06:12 2022 -Swapping column: NEA <=> EA... Fri Oct 21 16:06:12 2022 -Flipping column: BETA = - BETA... Fri Oct 21 16:06:12 2022 -Flipping column: EAF = 1 - EAF... Fri Oct 21 16:06:12 2022 -Flipping column: DIRECTION +-? <=> -+? ... Fri Oct 21 16:06:13 2022 -Changed the status for flipped variants : xxxxx[35]x -> xxxxx[12]x Fri Oct 21 16:06:13 2022 Finished converting successfully! Fri Oct 21 16:06:13 2022 Start to infer strand for palindromic SNPs... Fri Oct 21 16:06:13 2022 -Current Dataframe shape : 100000 x 12 Fri Oct 21 16:06:13 2022 -Reference vcf file: /Users/he/Documents/Mydata/eas_1kg_af/EAS.ALL.split_norm_af.1kgp3v5.hg19.vcf.gz Fri Oct 21 16:06:13 2022 -Alternative allele frequency in INFO: AF Fri Oct 21 16:06:14 2022 -Identified 14046 palindromic SNPs... Fri Oct 21 16:06:14 2022 -After filtering by MAF< 0.4 , the strand of 12814 palindromic SNPs will be inferred... Fri Oct 21 16:06:36 2022 -Non-palindromic : 76945 Fri Oct 21 16:06:36 2022 -Palindromic SNPs on + strand: 12456 Fri Oct 21 16:06:37 2022 -Palindromic SNPs on - strand and need to be flipped: 22 Fri Oct 21 16:06:37 2022 -Palindromic SNPs with maf not availble to infer : 1232 Fri Oct 21 16:06:37 2022 -Palindromic SNPs with no macthes or no information : 186 Fri Oct 21 16:06:38 2022 -Identified 8259 indistinguishable Indels... Fri Oct 21 16:06:38 2022 -Indistinguishable Indels will be inferred from reference vcf ref and alt... Fri Oct 21 16:07:11 2022 -Indels ea/nea match reference : 3520 Fri Oct 21 16:07:11 2022 -Indels ea/nea need to be flipped : 4468 Fri Oct 21 16:07:11 2022 -Indels with no macthes or no information : 271 Fri Oct 21 16:07:11 2022 -Current Dataframe shape : 100000 x 12 Fri Oct 21 16:07:12 2022 Start to flip allele-specific stats for standardized indels with status xxxx[123][67][6]: alt->ea , ref->nea ... Fri Oct 21 16:07:12 2022 -Flipping 4468 variants... Fri Oct 21 16:07:13 2022 -Swapping column: NEA <=> EA... Fri Oct 21 16:07:13 2022 -Flipping column: BETA = - BETA... Fri Oct 21 16:07:13 2022 -Flipping column: EAF = 1 - EAF... Fri Oct 21 16:07:13 2022 -Flipping column: DIRECTION +-? <=> -+? ... Fri Oct 21 16:07:13 2022 -Changed the status for flipped variants xxxx[123][67]6 -> xxxx[123][67]4 Fri Oct 21 16:07:13 2022 Start to flip allele-specific stats for palindromic SNPs with status xxxxx[12]5: (-)strand <=> (+)strand ... Fri Oct 21 16:07:13 2022 -Flipping 22 variants... Fri Oct 21 16:07:13 2022 -Flipping column: BETA = - BETA... Fri Oct 21 16:07:13 2022 -Flipping column: EAF = 1 - EAF... Fri Oct 21 16:07:13 2022 -Flipping column: DIRECTION +-? <=> -+? ... Fri Oct 21 16:07:13 2022 -Changed the status for flipped variants: xxxxx[012]5: -> xxxxx[012]2 Fri Oct 21 16:07:13 2022 Finished converting successfully! Fri Oct 21 16:07:13 2022 Start to annotate rsID based on chromosome and position information... Fri Oct 21 16:07:13 2022 -Current Dataframe shape : 100000 x 12 Fri Oct 21 16:07:13 2022 -SNPID-rsID text file: /Users/he/Documents/Mydata/EAS_1kg_af_dbsnp151.ALL.tsv Fri Oct 21 16:07:13 2022 -100000 rsID could be possibly fixed... Fri Oct 21 16:07:14 2022 -Setting block size: 5000000 Fri Oct 21 16:07:14 2022 -Loading block: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Fri Oct 21 16:11:57 2022 -rsID Annotation for 3250 need to be fixed! Fri Oct 21 16:11:57 2022 -Annotated 96750 rsID successfully! Fri Oct 21 16:11:57 2022 Start to assign rsID using vcf... Fri Oct 21 16:11:57 2022 -Current Dataframe shape : 100000 x 13 Fri Oct 21 16:11:57 2022 -CPU Cores to use : 3 Fri Oct 21 16:11:57 2022 -Reference VCF file: /Users/he/Documents/Mydata/All_20180423.vcf.gz Fri Oct 21 16:11:57 2022 -Assigning rsID based on chr:pos and ref:alt/alt:ref... Fri Oct 21 16:12:18 2022 -rsID Annotation for 582 need to be fixed! Fri Oct 21 16:12:18 2022 -Annotated 2668 rsID successfully! Fri Oct 21 16:12:18 2022 Start to sort the genome coordinates... Fri Oct 21 16:12:18 2022 -Current Dataframe shape : 100000 x 13 Fri Oct 21 16:12:18 2022 -Force converting POS to integers... Fri Oct 21 16:12:18 2022 -Sorting genome coordinates... Fri Oct 21 16:12:18 2022 Finished sorting genome coordinates successfully! Fri Oct 21 16:12:18 2022 Start to reorder the columns... Fri Oct 21 16:12:18 2022 -Current Dataframe shape : 100000 x 13 Fri Oct 21 16:12:18 2022 -Reordering columns to : SNPID,rsID,CHR,POS,EA,NEA,EAF,BETA,SE,P,N,DIRECTION,STATUS Fri Oct 21 16:12:18 2022 Finished sorting columns successfully! Sumstats summary You can check the summary of your sumstats by: mysumstats.summary() Format and Output You can then foremat your sumstats and output. gwaslab support commonly used formats. For details see: https://cloufield.github.io/gwaslab/Format/ mysumstats.to_format(\"clean_sumstats\",fmt=\"ldsc\") Liftover mysumstats.liftover(n_cores=1,from_build=\"19\", to_build=\"38\") Gwaslab only liftover CHR and POS, and when lifted, the last two digits status code will be rolled back to 99. Since for difference reference genome, the reference allele or strand might be reverse, so it is need to align and check agin. See details in Harmonization .","title":"Tutorial"},{"location":"Tutorial/#quick-start","text":"","title":"Quick Start"},{"location":"Tutorial/#import-gwaslab-and-load-data","text":"Using a jupyter notebook, we first import gwaslab package: import gwaslab as gl The sample sumstats we use in this study: !wget -O t2d_bbj.txt.gz http://jenger.riken.jp/14/ Let's import this raw sumstats into the gwaslab Sumstats Object by specifying the necessary columns, and all data are imported as strings. Note: you can either specify eaf (effect allele frequency) or neaf(non-effect allele frequency), if neaf is specified, it will be converted to eaf when loading sumstats. mysumstats = gl.Sumstats(\"t2d_bbj.txt.gz\", snpid=\"SNP\", chrom=\"CHR\", pos=\"POS\", ea=\"ALT\", nea=\"REF\", neaf=\"Frq\", beta=\"BETA\", se=\"SE\", p=\"P\", direction=\"Dir\", n=\"N\", build=\"19\") See details in SumstatsObject . Sumstats are loaded stored as pandas DataFrame, you can check the data by mysumstats.data SNPID CHR POS EA NEA EAF BETA SE P N DIRECTION STATUS 0 1:725932_G_A 1 725932 G A 0.9960 -0.0737 0.1394 0.5970 166718 -?+- 9999999 1 1:725933_A_G 1 725933 G A 0.0040 0.0737 0.1394 0.5973 166718 +?-+ 9999999 2 1:737801_T_C 1 737801 C T 0.0051 0.0490 0.1231 0.6908 166718 +?-+ 9999999 3 1:749963_T_TAA 1 749963 TAA T 0.8374 0.0213 0.0199 0.2846 166718 -?++ 9999999 4 1:751343_T_A 1 751343 T A 0.8593 0.0172 0.0156 0.2705 166718 -?++ 9999999 Maybe the first thing you want to check is the manhattan plot, you can do this with one line of code, gwaslab will perform a minimum QC for just the plotting. For details, please check: https://cloufield.github.io/gwaslab/Visualization/","title":"import gwaslab and load data"},{"location":"Tutorial/#quick-mqq-plot","text":"mysumstats.plot_mqq(skip=2) skip=2 : skip variants with -log10P<2 for plotting, which greatly improves plotting speed.","title":"quick mqq plot"},{"location":"Tutorial/#standardization-normalization","text":"It is needed to check ID,CHR,POS and alleles first before any manipulations: Simply run the following function and every thing will be checked. mysumstats.basic_check() .basic_check() is a wrapper of all the following basic functions, you can use these separately. mysumstats.fix_ID() mysumstats.fix_chr() mysumstats.fix_pos() mysumstats.fix_allele() mysumstats.check_sanity() mysumstats.normalize_allele() See details in Standardization .","title":"Standardization &amp; normalization"},{"location":"Tutorial/#fix-id","text":"Usually we want SNPID to be in a stadardized format chr:pos:ref:alt, we can use fix_id for this: mysumstats.fix_id(fixsep=True)","title":"Fix ID"},{"location":"Tutorial/#extract-lead-variants","text":"Let's extract the lead variants in each significant loci to check our data. The significant loci are detected based on a sliding window (default window size: 500kb) mysumstats.get_lead(anno=True) By specifying anno=True , gwaslab will also annotate the lead variant with its nearest gene names and distance. Note : gwaslab default genome build version is build=\"19\" (GRCh37/hg19), you can change it to build=\"38\" (GRCh38/hg38) when needed. SNPID CHR POS EA NEA EAF BETA SE P N DIRECTION STATUS LOCATION GENE 96739 1:22068326:A:G 1 22068326 G A 0.7550 0.0621 0.0103 1.629000e-09 191764 ++++ 9960099 0 USP48 213860 1:51103268:T:C 1 51103268 C T 0.7953 -0.0802 0.0120 2.519000e-11 191764 ---- 9960099 0 FAF1 534095 1:154309595:TA:T 1 154309595 TA T 0.0947 -0.0915 0.0166 3.289000e-08 191764 ---- 9960399 0 ATP8B2 969974 2:640986:CACAT:C 2 640986 C CACAT 0.9006 -0.0946 0.0150 2.665000e-10 191764 ---- 9960399 26349 TMEM18 1091807 2:27734972:G:A 2 27734972 G A 0.5605 0.0691 0.0088 3.897000e-15 191764 ++++ 9960099 0 GCKR See details in ExtractLead .","title":"Extract lead variants"},{"location":"Tutorial/#customized-manhattan-plot","text":"GWASlab can plot more complicated manhattan plot. For details, please check: https://cloufield.github.io/gwaslab/Visualization/ mysumstats.plot_mqq(snpid=\"SNPID\",mode=\"mqq\", cut=20,skip=3, eaf=\"EAF\", anno=True,anno_set=[\"9:22132729_A_G\",\"6:20688121_T_A\",\"9:22132729_A_G\",\"15:62394264_G_C\"] , pinpoint=[\"9:22132729_A_G\",\"5:176513896_C_A\"], highlight=[\"7:127253550_C_T\",\"19:46166604_C_T\"], highlight_windowkb =1000, stratified=True, marker_size=(5,10), figargs={\"figsize\":(15,5),\"dpi\":300}) See details in Visualization .","title":"Customized manhattan plot"},{"location":"Tutorial/#regional-plot","text":"Quick regional plot without LD-information mysumstats.plot_mqq(mode=\"r\",region=(7,156538803,157538803),region_grid=True) Note : gwaslab default genome build version is build=\"19\" (GRCh37/hg19), you can change it to build=\"38\" (GRCh38/hg38) when needed. For gene tracks, default is gtf_path=\"ensembl\" , you can also use gtf_path=\"refseq\" (NCBA RefSeq) Full regional plot using a user-provided vcf (e.g 1000 genome, see Reference: https://cloufield.github.io/gwaslab/Reference/) ) mysumstats.plot_mqq(mode=\"r\",region=(7,156538803,157538803),region_grid=True,anno=True, vcf_path=\"/Users/he/Documents/Mydata/eas_1kg_af/EAS.chr7.split_norm_af.1kgp3v5.vcf.gz\")","title":"Regional plot"},{"location":"Tutorial/#random-sampling","text":"There are more than 10 million variants in the original sumstats and it will take long to process the entrie dataset. Since it might take a while to process the entire datasets, let us just random sample 1 million variants for this tutorial. mysumstats.random_variants(n=100000)","title":"Random sampling"},{"location":"Tutorial/#harmonise-the-sumstats","text":"ref_seq : reference genome fasta file for allele alignment ref_rsid_tsv : tsv file for annotation of common used variants ref_rsid_vcf : vcf file for annotation of other variants ref_infer : vcf file with allele frequency information for inferring strand and comparing allele frequency ref_alt_freq : field in INFO of vcf file for alternative allele frequency For details see: https://cloufield.github.io/gwaslab/Harmonization/ mysumstats.harmonize(basic_check=False, n_cores=3, ref_seq=\"/Users/he/Documents/Mydata/human_g1k_v37.fasta\", ref_rsid_tsv=\"/Users/he/Documents/Mydata/EAS_1kg_af_dbsnp151.ALL.tsv\", ref_rsid_vcf=\"/Users/he/Documents/Mydata/All_20180423.vcf.gz\", ref_infer=\"/Users/he/Documents/Mydata/eas_1kg_af/EAS.ALL.split_norm_af.1kgp3v5.hg19.vcf.gz\",ref_alt_freq=\"AF\") gwaslab will then harmonize the sumstats based on reference files. Fri Oct 21 16:05:39 2022 Start to check if NEA is aligned with reference sequence... Fri Oct 21 16:05:39 2022 -Current Dataframe shape : 100000 x 12 Fri Oct 21 16:05:39 2022 -Reference genome fasta file: /Users/he/Documents/Mydata/human_g1k_v37.fasta Fri Oct 21 16:05:39 2022 -Checking records: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 X Y MT Fri Oct 21 16:06:11 2022 -Variants allele on given reference sequence : 41646 Fri Oct 21 16:06:11 2022 -Variants flipped : 50095 Fri Oct 21 16:06:11 2022 -Raw Matching rate : 91.74% Fri Oct 21 16:06:11 2022 -Variants inferred reverse_complement : 0 Fri Oct 21 16:06:11 2022 -Variants inferred reverse_complement_flipped : 0 Fri Oct 21 16:06:11 2022 -Both allele on genome + unable to distinguish : 8259 Fri Oct 21 16:06:11 2022 -Variants not on given reference sequence : 0 Fri Oct 21 16:06:11 2022 -Current Dataframe shape : 100000 x 12 Fri Oct 21 16:06:12 2022 Start to flip allele-specific stats for SNPs with status xxxxx[35]x: alt->ea , ref->nea ... Fri Oct 21 16:06:12 2022 -Flipping 50095 variants... Fri Oct 21 16:06:12 2022 -Swapping column: NEA <=> EA... Fri Oct 21 16:06:12 2022 -Flipping column: BETA = - BETA... Fri Oct 21 16:06:12 2022 -Flipping column: EAF = 1 - EAF... Fri Oct 21 16:06:12 2022 -Flipping column: DIRECTION +-? <=> -+? ... Fri Oct 21 16:06:13 2022 -Changed the status for flipped variants : xxxxx[35]x -> xxxxx[12]x Fri Oct 21 16:06:13 2022 Finished converting successfully! Fri Oct 21 16:06:13 2022 Start to infer strand for palindromic SNPs... Fri Oct 21 16:06:13 2022 -Current Dataframe shape : 100000 x 12 Fri Oct 21 16:06:13 2022 -Reference vcf file: /Users/he/Documents/Mydata/eas_1kg_af/EAS.ALL.split_norm_af.1kgp3v5.hg19.vcf.gz Fri Oct 21 16:06:13 2022 -Alternative allele frequency in INFO: AF Fri Oct 21 16:06:14 2022 -Identified 14046 palindromic SNPs... Fri Oct 21 16:06:14 2022 -After filtering by MAF< 0.4 , the strand of 12814 palindromic SNPs will be inferred... Fri Oct 21 16:06:36 2022 -Non-palindromic : 76945 Fri Oct 21 16:06:36 2022 -Palindromic SNPs on + strand: 12456 Fri Oct 21 16:06:37 2022 -Palindromic SNPs on - strand and need to be flipped: 22 Fri Oct 21 16:06:37 2022 -Palindromic SNPs with maf not availble to infer : 1232 Fri Oct 21 16:06:37 2022 -Palindromic SNPs with no macthes or no information : 186 Fri Oct 21 16:06:38 2022 -Identified 8259 indistinguishable Indels... Fri Oct 21 16:06:38 2022 -Indistinguishable Indels will be inferred from reference vcf ref and alt... Fri Oct 21 16:07:11 2022 -Indels ea/nea match reference : 3520 Fri Oct 21 16:07:11 2022 -Indels ea/nea need to be flipped : 4468 Fri Oct 21 16:07:11 2022 -Indels with no macthes or no information : 271 Fri Oct 21 16:07:11 2022 -Current Dataframe shape : 100000 x 12 Fri Oct 21 16:07:12 2022 Start to flip allele-specific stats for standardized indels with status xxxx[123][67][6]: alt->ea , ref->nea ... Fri Oct 21 16:07:12 2022 -Flipping 4468 variants... Fri Oct 21 16:07:13 2022 -Swapping column: NEA <=> EA... Fri Oct 21 16:07:13 2022 -Flipping column: BETA = - BETA... Fri Oct 21 16:07:13 2022 -Flipping column: EAF = 1 - EAF... Fri Oct 21 16:07:13 2022 -Flipping column: DIRECTION +-? <=> -+? ... Fri Oct 21 16:07:13 2022 -Changed the status for flipped variants xxxx[123][67]6 -> xxxx[123][67]4 Fri Oct 21 16:07:13 2022 Start to flip allele-specific stats for palindromic SNPs with status xxxxx[12]5: (-)strand <=> (+)strand ... Fri Oct 21 16:07:13 2022 -Flipping 22 variants... Fri Oct 21 16:07:13 2022 -Flipping column: BETA = - BETA... Fri Oct 21 16:07:13 2022 -Flipping column: EAF = 1 - EAF... Fri Oct 21 16:07:13 2022 -Flipping column: DIRECTION +-? <=> -+? ... Fri Oct 21 16:07:13 2022 -Changed the status for flipped variants: xxxxx[012]5: -> xxxxx[012]2 Fri Oct 21 16:07:13 2022 Finished converting successfully! Fri Oct 21 16:07:13 2022 Start to annotate rsID based on chromosome and position information... Fri Oct 21 16:07:13 2022 -Current Dataframe shape : 100000 x 12 Fri Oct 21 16:07:13 2022 -SNPID-rsID text file: /Users/he/Documents/Mydata/EAS_1kg_af_dbsnp151.ALL.tsv Fri Oct 21 16:07:13 2022 -100000 rsID could be possibly fixed... Fri Oct 21 16:07:14 2022 -Setting block size: 5000000 Fri Oct 21 16:07:14 2022 -Loading block: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Fri Oct 21 16:11:57 2022 -rsID Annotation for 3250 need to be fixed! Fri Oct 21 16:11:57 2022 -Annotated 96750 rsID successfully! Fri Oct 21 16:11:57 2022 Start to assign rsID using vcf... Fri Oct 21 16:11:57 2022 -Current Dataframe shape : 100000 x 13 Fri Oct 21 16:11:57 2022 -CPU Cores to use : 3 Fri Oct 21 16:11:57 2022 -Reference VCF file: /Users/he/Documents/Mydata/All_20180423.vcf.gz Fri Oct 21 16:11:57 2022 -Assigning rsID based on chr:pos and ref:alt/alt:ref... Fri Oct 21 16:12:18 2022 -rsID Annotation for 582 need to be fixed! Fri Oct 21 16:12:18 2022 -Annotated 2668 rsID successfully! Fri Oct 21 16:12:18 2022 Start to sort the genome coordinates... Fri Oct 21 16:12:18 2022 -Current Dataframe shape : 100000 x 13 Fri Oct 21 16:12:18 2022 -Force converting POS to integers... Fri Oct 21 16:12:18 2022 -Sorting genome coordinates... Fri Oct 21 16:12:18 2022 Finished sorting genome coordinates successfully! Fri Oct 21 16:12:18 2022 Start to reorder the columns... Fri Oct 21 16:12:18 2022 -Current Dataframe shape : 100000 x 13 Fri Oct 21 16:12:18 2022 -Reordering columns to : SNPID,rsID,CHR,POS,EA,NEA,EAF,BETA,SE,P,N,DIRECTION,STATUS Fri Oct 21 16:12:18 2022 Finished sorting columns successfully!","title":"Harmonise the sumstats"},{"location":"Tutorial/#sumstats-summary","text":"You can check the summary of your sumstats by: mysumstats.summary()","title":"Sumstats summary"},{"location":"Tutorial/#format-and-output","text":"You can then foremat your sumstats and output. gwaslab support commonly used formats. For details see: https://cloufield.github.io/gwaslab/Format/ mysumstats.to_format(\"clean_sumstats\",fmt=\"ldsc\")","title":"Format and Output"},{"location":"Tutorial/#liftover","text":"mysumstats.liftover(n_cores=1,from_build=\"19\", to_build=\"38\") Gwaslab only liftover CHR and POS, and when lifted, the last two digits status code will be rolled back to 99. Since for difference reference genome, the reference allele or strand might be reverse, so it is need to align and check agin. See details in Harmonization .","title":"Liftover"},{"location":"UpdateLogs/","text":"Update Logs v3.3.4 coming soon v3.3.3 added Miami plot added Brisbane plot updated tutorials mqq plot annotation: new customization options v3.3.2 - 20221021 added forcefixid for fix_id() fixed bugs for plotting gene tracks v3.3.1 extract novel loci given a list of known lead variants fixed bugs in fill_data() fixed path for hapmap3 snps for infer_build() v3.3.0 2022/10/18 added forest plot fixed options for mqqplot supported vcf v3.2.0 incorporated pyensembl and scikit-allel. get_lead() : support automatic gene name annotation (using pyensembl) to_format(): support common sumstats formats support 1-based bed-like formats for VEP support 0-based bed-like formats manhattan plot: optimized plotting logic annotate gene names added regional plot feature using a user-provided reference panel comparison effect plot: fix using OR v3.1.0 implemented formatbook: easily import sumstats and output sumstats in certain formats (support for commonly used formats including ldsc, plink, plink2, gwas-ssf, saige, regenie, fastgwa, metal, mrmega, pgscatalog, pgscatalog_hm, gwascatalog, gwascatalog_hm and gwaslab) added .filter_region_in/out using bed files (or in-built regions like high-ld or hla) implemented .summay() methods. optimized rsID annotation pipeline. Support annotation using curated chr:pos:ref:alt - rsID tsv for quick annotation. changed some datatypes and optimized memory usage. replaced pyVCF with pySAM","title":"Update logs"},{"location":"UpdateLogs/#update-logs","text":"","title":"Update Logs"},{"location":"UpdateLogs/#v334-coming-soon","text":"","title":"v3.3.4 coming soon"},{"location":"UpdateLogs/#v333","text":"added Miami plot added Brisbane plot updated tutorials mqq plot annotation: new customization options","title":"v3.3.3"},{"location":"UpdateLogs/#v332-20221021","text":"added forcefixid for fix_id() fixed bugs for plotting gene tracks","title":"v3.3.2 - 20221021"},{"location":"UpdateLogs/#v331","text":"extract novel loci given a list of known lead variants fixed bugs in fill_data() fixed path for hapmap3 snps for infer_build()","title":"v3.3.1"},{"location":"UpdateLogs/#v330-20221018","text":"added forest plot fixed options for mqqplot supported vcf","title":"v3.3.0 2022/10/18"},{"location":"UpdateLogs/#v320","text":"incorporated pyensembl and scikit-allel. get_lead() : support automatic gene name annotation (using pyensembl) to_format(): support common sumstats formats support 1-based bed-like formats for VEP support 0-based bed-like formats manhattan plot: optimized plotting logic annotate gene names added regional plot feature using a user-provided reference panel comparison effect plot: fix using OR","title":"v3.2.0"},{"location":"UpdateLogs/#v310","text":"implemented formatbook: easily import sumstats and output sumstats in certain formats (support for commonly used formats including ldsc, plink, plink2, gwas-ssf, saige, regenie, fastgwa, metal, mrmega, pgscatalog, pgscatalog_hm, gwascatalog, gwascatalog_hm and gwaslab) added .filter_region_in/out using bed files (or in-built regions like high-ld or hla) implemented .summay() methods. optimized rsID annotation pipeline. Support annotation using curated chr:pos:ref:alt - rsID tsv for quick annotation. changed some datatypes and optimized memory usage. replaced pyVCF with pySAM","title":"v3.1.0"},{"location":"Visualization/","text":"Manhattan plot and QQ plot : plot_mqq() Usage import gwaslab as gl mydata = gl.Sumstats(....) mydata.plot_mqq( mlog10p=\"MLOG10P\", scaled=False, mode=\"mqq\", mqqratio=3, windowsizekb=500, anno=None, anno_set=[], anno_alias={}, anno_d={}, arm_offset=50, arm_scale=1, cut=0, skip=0, cutfactor=10, cut_line_color=\"#ebebeb\", sig_level=5e-8, sig_line_color=\"grey\", suggestive_sig_level=5e-6, highlight = [], highlight_color=\"#CB132D\", highlight_windowkb = 500, pinpoint=[], pinpoint_color =\"red\", stratified=False, maf_bins=[(0, 0.01), (0.01, 0.05), (0.05, 0.25),(0.25,0.5)], maf_bin_colors = [\"#f0ad4e\",\"#5cb85c\", \"#5bc0de\",\"#000042\"], gc=True, title =None, mtitle=None, qtitle=None, figargs= {\"figsize\":(15,5),\"dpi\":100}, fontsize = 10, colors=[\"#597FBD\",\"#74BAD3\"], marker_size=(5,25), use_rank=False, verbose=True, repel_force=0.03, build=\"19\", title_pad=1.08, save=None, saveargs={\"dpi\":400,\"facecolor\":\"white\"}, ): Quick plot mysumstatsysumstats.plot_mqq() Customized plot example mysumstats.plot_mqq( mode=\"qqm\", cut=14, skip=3, anno_set=[\"rs12509595\",\"rs7989823\"] , pinpoint=[\"rs7989823\"], highlight=[\"rs12509595\",\"19:15040733:T:C\"], highlight_windowkb =1000, stratified=True, marker_size=(5,10), figargs={\"figsize\":(15,5),\"dpi\":300}) Options Manhattan and QQ plot layout mode : determine the layout of manhattan plot and qq plot. \"mqq\" or \"qqm\" : side-by-side manhattan and QQ plt. mqq : left manhatan, right QQ qqm : left QQ , right manhatan \"m\" : only manhattan plot \"qq\" : only qq plot mqqratio : width ratio Skip \"low\" and shrink \"high\" skip : sometimes it is not necessary to plot all variants, we can skip the insignicant variants . For example, we can exclude varints with -log10p lower than 3 from the plot by specifying skip=3 cut : loci with extremly large -log10(P) value are very likely to dwarf other significant loci , so we want to scale down the extrame loci from a certain threshold. cutfactor : shrinkage factor, default is 10 cut_line_color : the color of the line above which y axis is rescaled sig_level=5e-8 : genome-wide significance threshold Annotation anno : boolean or string or \"GENENAME\" boolean : anno = True , the variants to annotate will be selected automatically using a sliding window with windowsize=500 kb. chr:pos string : the column name used for annotation \"GENENAME\" : automatically annotate nrearest gene names, using pyensembl. (remember to specify build , default is build=\"19\" ) repel_force : when the annotation overlaps with other, try increasing the repel_force to increase the padding between annotations. (deault is 0.01) anno_set : if you want to annotate only a few specific variants, you can simply provide a list of SNPIDs. anno_alias : snpid:text dictionary for customized annotation example: mysumstats.plot_mqq(skip=3,anno=True) mysumstats.plot_mqq(skip=3,anno=\"GENENAME\",build=\"19\") mysumstats.plot_mqq(skip=3, anno_set=[\"rs12509595\",\"19:15040733:T:C\"]) mysumstats.plot_mqq(skip=3, anno_set=[\"rs12509595\",\"19:15040733:T:C\"], anno_alias={\"rs12509595\":\"anything you want here\"}) Adjust arm position anno_d : dict ,key is the number of arm starting form 0, value is the direction you want the arm to shift towards . For example, anno_d = {4:\"r\"} means shift the 4th arm to the right arm_offset : float shift distance in points arm_scale : float factors to adjust the height for all arms arm_scale_d : dict factors to adjust the height for specific arms. key is the number of arm startinf form 0, value is the factor which will be multiplied to arm height. mysumstats.plot_mqq(skip=2,anno=True) mysumstats.plot_mqq(skip=2,anno=True, anno_d={1:\"l\",3:\"r\"}, arm_offset=50) mysumstats.plot_mqq(skip=2,anno=True,arm_scale=1.5) mysumstats.plot_mqq(skip=2,anno=True,arm_scale_d={1:1.5,2:1.2,3:1.1}) Highlight specified loci Highlight specified loci (color all variants in a region by specifying variants and the length of flanking regions). highlight : list specify the variants of loci for highlighting. highlight_color : string specify the color ussed for highlighting. highlight_windowkb : int specify the span of highlighted region (deault: highlight_windowkb = 500 kp) Pinpoint specified variants Pinpoint certain variants in the manhattan plot. pinpoint : a list of SNPIDs pinpoint_color : color for pinpoint mysumstats.plot_mqq(skip=3,anno=\"GENENAME\",build=\"19\", highlight=[\"rs12509595\",\"rs7989823\"], pinpoint=[\"rs671\",\"19:15040733:T:C\"]) Maf-stratified QQ plot stratified : boolean if True, plot MAF straitified QQ plot. Require EAF in sumstats. maf_bins : list maf bins for straitification. (default: maf_bins=[(0, 0.01), (0.01, 0.05), (0.05, 0.25),(0.25,0.5)] ) maf_bin_colors : list colors used for each bin. (default: maf_bin_colors = [\"#f0ad4e\",\"#5cb85c\", \"#5bc0de\",\"#000042\"] ) Colors and Fonts mysumstats.plot_mqq( colors=[\"#597FBD\",\"#74BAD3\"], cut_line_color=\"#ebebeb\", sig_line_color=\"grey\", highlight_color=\"#CB132D\", pinpoint_color =\"red\", maf_bin_colors = [\"#f0ad4e\",\"#5cb85c\", \"#5bc0de\",\"#000042\"], fontsize = 10, marker_size=(5,25) ) Titles mysumstats.plot_mqq( title =None, mtitle=None, qtitle=None, title_pad=1.08 ) Save plots mysumstats.plot_mqq(save=\"mymqqplots.png\",saveargs={\"dpi\":400,\"facecolor\":\"white\"}) save : string ,path for saved plot saveargs : other parameters for matplotlib savefig function.","title":"Manhattan & QQ plot"},{"location":"Visualization/#manhattan-plot-and-qq-plot-plot_mqq","text":"","title":"Manhattan plot and QQ plot : plot_mqq()"},{"location":"Visualization/#usage","text":"import gwaslab as gl mydata = gl.Sumstats(....) mydata.plot_mqq( mlog10p=\"MLOG10P\", scaled=False, mode=\"mqq\", mqqratio=3, windowsizekb=500, anno=None, anno_set=[], anno_alias={}, anno_d={}, arm_offset=50, arm_scale=1, cut=0, skip=0, cutfactor=10, cut_line_color=\"#ebebeb\", sig_level=5e-8, sig_line_color=\"grey\", suggestive_sig_level=5e-6, highlight = [], highlight_color=\"#CB132D\", highlight_windowkb = 500, pinpoint=[], pinpoint_color =\"red\", stratified=False, maf_bins=[(0, 0.01), (0.01, 0.05), (0.05, 0.25),(0.25,0.5)], maf_bin_colors = [\"#f0ad4e\",\"#5cb85c\", \"#5bc0de\",\"#000042\"], gc=True, title =None, mtitle=None, qtitle=None, figargs= {\"figsize\":(15,5),\"dpi\":100}, fontsize = 10, colors=[\"#597FBD\",\"#74BAD3\"], marker_size=(5,25), use_rank=False, verbose=True, repel_force=0.03, build=\"19\", title_pad=1.08, save=None, saveargs={\"dpi\":400,\"facecolor\":\"white\"}, ):","title":"Usage"},{"location":"Visualization/#quick-plot","text":"mysumstatsysumstats.plot_mqq()","title":"Quick plot"},{"location":"Visualization/#customized-plot-example","text":"mysumstats.plot_mqq( mode=\"qqm\", cut=14, skip=3, anno_set=[\"rs12509595\",\"rs7989823\"] , pinpoint=[\"rs7989823\"], highlight=[\"rs12509595\",\"19:15040733:T:C\"], highlight_windowkb =1000, stratified=True, marker_size=(5,10), figargs={\"figsize\":(15,5),\"dpi\":300})","title":"Customized plot example"},{"location":"Visualization/#options","text":"","title":"Options"},{"location":"Visualization/#manhattan-and-qq-plot-layout","text":"mode : determine the layout of manhattan plot and qq plot. \"mqq\" or \"qqm\" : side-by-side manhattan and QQ plt. mqq : left manhatan, right QQ qqm : left QQ , right manhatan \"m\" : only manhattan plot \"qq\" : only qq plot mqqratio : width ratio","title":"Manhattan and QQ plot layout"},{"location":"Visualization/#skip-low-and-shrink-high","text":"skip : sometimes it is not necessary to plot all variants, we can skip the insignicant variants . For example, we can exclude varints with -log10p lower than 3 from the plot by specifying skip=3 cut : loci with extremly large -log10(P) value are very likely to dwarf other significant loci , so we want to scale down the extrame loci from a certain threshold. cutfactor : shrinkage factor, default is 10 cut_line_color : the color of the line above which y axis is rescaled sig_level=5e-8 : genome-wide significance threshold","title":"Skip \"low\" and shrink \"high\""},{"location":"Visualization/#annotation","text":"anno : boolean or string or \"GENENAME\" boolean : anno = True , the variants to annotate will be selected automatically using a sliding window with windowsize=500 kb. chr:pos string : the column name used for annotation \"GENENAME\" : automatically annotate nrearest gene names, using pyensembl. (remember to specify build , default is build=\"19\" ) repel_force : when the annotation overlaps with other, try increasing the repel_force to increase the padding between annotations. (deault is 0.01) anno_set : if you want to annotate only a few specific variants, you can simply provide a list of SNPIDs. anno_alias : snpid:text dictionary for customized annotation","title":"Annotation"},{"location":"Visualization/#example","text":"mysumstats.plot_mqq(skip=3,anno=True) mysumstats.plot_mqq(skip=3,anno=\"GENENAME\",build=\"19\") mysumstats.plot_mqq(skip=3, anno_set=[\"rs12509595\",\"19:15040733:T:C\"]) mysumstats.plot_mqq(skip=3, anno_set=[\"rs12509595\",\"19:15040733:T:C\"], anno_alias={\"rs12509595\":\"anything you want here\"})","title":"example:"},{"location":"Visualization/#adjust-arm-position","text":"anno_d : dict ,key is the number of arm starting form 0, value is the direction you want the arm to shift towards . For example, anno_d = {4:\"r\"} means shift the 4th arm to the right arm_offset : float shift distance in points arm_scale : float factors to adjust the height for all arms arm_scale_d : dict factors to adjust the height for specific arms. key is the number of arm startinf form 0, value is the factor which will be multiplied to arm height. mysumstats.plot_mqq(skip=2,anno=True) mysumstats.plot_mqq(skip=2,anno=True, anno_d={1:\"l\",3:\"r\"}, arm_offset=50) mysumstats.plot_mqq(skip=2,anno=True,arm_scale=1.5) mysumstats.plot_mqq(skip=2,anno=True,arm_scale_d={1:1.5,2:1.2,3:1.1})","title":"Adjust arm position"},{"location":"Visualization/#highlight-specified-loci","text":"Highlight specified loci (color all variants in a region by specifying variants and the length of flanking regions). highlight : list specify the variants of loci for highlighting. highlight_color : string specify the color ussed for highlighting. highlight_windowkb : int specify the span of highlighted region (deault: highlight_windowkb = 500 kp)","title":"Highlight specified loci"},{"location":"Visualization/#pinpoint-specified-variants","text":"Pinpoint certain variants in the manhattan plot. pinpoint : a list of SNPIDs pinpoint_color : color for pinpoint mysumstats.plot_mqq(skip=3,anno=\"GENENAME\",build=\"19\", highlight=[\"rs12509595\",\"rs7989823\"], pinpoint=[\"rs671\",\"19:15040733:T:C\"])","title":"Pinpoint specified variants"},{"location":"Visualization/#maf-stratified-qq-plot","text":"stratified : boolean if True, plot MAF straitified QQ plot. Require EAF in sumstats. maf_bins : list maf bins for straitification. (default: maf_bins=[(0, 0.01), (0.01, 0.05), (0.05, 0.25),(0.25,0.5)] ) maf_bin_colors : list colors used for each bin. (default: maf_bin_colors = [\"#f0ad4e\",\"#5cb85c\", \"#5bc0de\",\"#000042\"] )","title":"Maf-stratified QQ plot"},{"location":"Visualization/#colors-and-fonts","text":"mysumstats.plot_mqq( colors=[\"#597FBD\",\"#74BAD3\"], cut_line_color=\"#ebebeb\", sig_line_color=\"grey\", highlight_color=\"#CB132D\", pinpoint_color =\"red\", maf_bin_colors = [\"#f0ad4e\",\"#5cb85c\", \"#5bc0de\",\"#000042\"], fontsize = 10, marker_size=(5,25) )","title":"Colors and Fonts"},{"location":"Visualization/#titles","text":"mysumstats.plot_mqq( title =None, mtitle=None, qtitle=None, title_pad=1.08 )","title":"Titles"},{"location":"Visualization/#save-plots","text":"mysumstats.plot_mqq(save=\"mymqqplots.png\",saveargs={\"dpi\":400,\"facecolor\":\"white\"}) save : string ,path for saved plot saveargs : other parameters for matplotlib savefig function.","title":"Save plots"}]}